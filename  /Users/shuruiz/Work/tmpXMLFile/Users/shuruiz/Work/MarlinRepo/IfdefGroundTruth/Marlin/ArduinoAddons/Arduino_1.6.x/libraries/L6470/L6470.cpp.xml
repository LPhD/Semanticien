<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" xmlns:PREFIX="http://www.sdml.info/srcML/position" language="C++" filename=" /Users/shuruiz/Work/tmpXMLFile//Users/shuruiz/Work/MarlinRepo/IfdefGroundTruth/Marlin/ArduinoAddons/Arduino_1.6.x/libraries/L6470/L6470.cpp" PREFIX:tabs="8"><comment type="line" format="doxygen" PREFIX:line="1" PREFIX:column="1">////////////////////////////////////////////////////////////</comment>
<comment type="line" PREFIX:line="2" PREFIX:column="1">//ORIGINAL CODE 12/12/2011- Mike Hord, SparkFun Electronics</comment>
<comment type="line" PREFIX:line="3" PREFIX:column="1">//LIBRARY Created by Adam Meyer of bildr Aug 18th 2012</comment>
<comment type="line" PREFIX:line="4" PREFIX:column="1">//Released as MIT license</comment>
<comment type="line" format="doxygen" PREFIX:line="5" PREFIX:column="1">////////////////////////////////////////////////////////////</comment>

<cpp:include PREFIX:line="7" PREFIX:column="1">#<cpp:directive PREFIX:line="7" PREFIX:column="2">include</cpp:directive> <cpp:file PREFIX:line="7" PREFIX:column="10">&lt;Arduino.h&gt;</cpp:file></cpp:include>
<cpp:include PREFIX:line="8" PREFIX:column="1">#<cpp:directive PREFIX:line="8" PREFIX:column="2">include</cpp:directive> <cpp:file PREFIX:line="8" PREFIX:column="10">"L6470.h"</cpp:file></cpp:include>
<cpp:include PREFIX:line="9" PREFIX:column="1">#<cpp:directive PREFIX:line="9" PREFIX:column="2">include</cpp:directive> <cpp:file PREFIX:line="9" PREFIX:column="10">&lt;SPI.h&gt;</cpp:file></cpp:include>

<cpp:define PREFIX:line="11" PREFIX:column="1">#<cpp:directive PREFIX:line="11" PREFIX:column="2">define</cpp:directive> <cpp:macro><name PREFIX:line="11" PREFIX:column="9">ENABLE_RESET_PIN</name></cpp:macro>	<cpp:value PREFIX:line="11" PREFIX:column="33">0</cpp:value></cpp:define>
<cpp:define PREFIX:line="12" PREFIX:column="1">#<cpp:directive PREFIX:line="12" PREFIX:column="2">define</cpp:directive> <cpp:macro><name PREFIX:line="12" PREFIX:column="9">K_VALUE</name></cpp:macro>			<cpp:value PREFIX:line="12" PREFIX:column="33">100</cpp:value></cpp:define>

<constructor><name><name PREFIX:line="14" PREFIX:column="1">L6470</name>::<name PREFIX:line="14" PREFIX:column="8">L6470</name></name><parameter_list PREFIX:line="14" PREFIX:column="13">(<param><decl><type><name PREFIX:line="14" PREFIX:column="14">int</name></type> <name PREFIX:line="14" PREFIX:column="18">SSPin</name></decl></param>)</parameter_list><block PREFIX:line="14" PREFIX:column="24">{
  <expr_stmt><expr><name PREFIX:line="15" PREFIX:column="3">_SSPin</name> = <name PREFIX:line="15" PREFIX:column="12">SSPin</name></expr>;</expr_stmt>
  <comment type="line" PREFIX:line="16" PREFIX:column="3">// Serial.begin(9600);</comment>
}</block></constructor>

<function><type><name PREFIX:line="19" PREFIX:column="1">void</name></type> <name><name PREFIX:line="19" PREFIX:column="6">L6470</name>::<name PREFIX:line="19" PREFIX:column="13">init</name></name><parameter_list PREFIX:line="19" PREFIX:column="17">(<param><decl><type><name PREFIX:line="19" PREFIX:column="18">int</name></type> <name PREFIX:line="19" PREFIX:column="22">k_value</name></decl></param>)</parameter_list><block PREFIX:line="19" PREFIX:column="30">{
  <comment type="line" PREFIX:line="20" PREFIX:column="3">// This is the generic initialization function to set up the Arduino to</comment>
  <comment type="line" PREFIX:line="21" PREFIX:column="3">// communicate with the dSPIN chip.</comment>
  
  <comment type="line" PREFIX:line="23" PREFIX:column="3">// set up the input/output pins for the application.</comment>
  <expr_stmt><expr><call><name PREFIX:line="24" PREFIX:column="3">pinMode</name><argument_list PREFIX:line="24" PREFIX:column="10">(<argument><expr><name PREFIX:line="24" PREFIX:column="11">SLAVE_SELECT_PIN</name></expr></argument>, <argument><expr><name PREFIX:line="24" PREFIX:column="29">OUTPUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line" PREFIX:line="24" PREFIX:column="38">// The SPI peripheral REQUIRES the hardware SS pin-</comment>
  <comment type="line" PREFIX:line="25" PREFIX:column="3">// pin 10- to be an output. This is in here just</comment>
  <comment type="line" PREFIX:line="26" PREFIX:column="3">// in case some future user makes something other</comment>
  <comment type="line" PREFIX:line="27" PREFIX:column="3">// than pin 10 the SS pin.</comment>
  
  <expr_stmt><expr><call><name PREFIX:line="29" PREFIX:column="3">pinMode</name><argument_list PREFIX:line="29" PREFIX:column="10">(<argument><expr><name PREFIX:line="29" PREFIX:column="11">_SSPin</name></expr></argument>, <argument><expr><name PREFIX:line="29" PREFIX:column="19">OUTPUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name PREFIX:line="30" PREFIX:column="3">digitalWrite</name><argument_list PREFIX:line="30" PREFIX:column="15">(<argument><expr><name PREFIX:line="30" PREFIX:column="16">_SSPin</name></expr></argument>, <argument><expr><name PREFIX:line="30" PREFIX:column="24">HIGH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name PREFIX:line="31" PREFIX:column="3">pinMode</name><argument_list PREFIX:line="31" PREFIX:column="10">(<argument><expr><name PREFIX:line="31" PREFIX:column="11">MOSI</name></expr></argument>, <argument><expr><name PREFIX:line="31" PREFIX:column="17">OUTPUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name PREFIX:line="32" PREFIX:column="3">pinMode</name><argument_list PREFIX:line="32" PREFIX:column="10">(<argument><expr><name PREFIX:line="32" PREFIX:column="11">MISO</name></expr></argument>, <argument><expr><name PREFIX:line="32" PREFIX:column="17">INPUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name PREFIX:line="33" PREFIX:column="3">pinMode</name><argument_list PREFIX:line="33" PREFIX:column="10">(<argument><expr><name PREFIX:line="33" PREFIX:column="11">SCK</name></expr></argument>, <argument><expr><name PREFIX:line="33" PREFIX:column="16">OUTPUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name PREFIX:line="34" PREFIX:column="3">pinMode</name><argument_list PREFIX:line="34" PREFIX:column="10">(<argument><expr><name PREFIX:line="34" PREFIX:column="11">BUSYN</name></expr></argument>, <argument><expr><name PREFIX:line="34" PREFIX:column="18">INPUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if PREFIX:line="35" PREFIX:column="1">#<cpp:directive PREFIX:line="35" PREFIX:column="2">if</cpp:directive> <expr PREFIX:line="35" PREFIX:column="5">(<name PREFIX:line="35" PREFIX:column="6">ENABLE_RESET_PIN</name> == 1)</expr></cpp:if>
  <expr_stmt><expr><call><name PREFIX:line="36" PREFIX:column="3">pinMode</name><argument_list PREFIX:line="36" PREFIX:column="10">(<argument><expr><name PREFIX:line="36" PREFIX:column="11">RESET</name></expr></argument>, <argument><expr><name PREFIX:line="36" PREFIX:column="18">OUTPUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line" PREFIX:line="37" PREFIX:column="3">// reset the dSPIN chip. This could also be accomplished by</comment>
  <comment type="line" PREFIX:line="38" PREFIX:column="3">// calling the "L6470::ResetDev()" function after SPI is initialized.</comment>
  <expr_stmt><expr><call><name PREFIX:line="39" PREFIX:column="3">digitalWrite</name><argument_list PREFIX:line="39" PREFIX:column="15">(<argument><expr><name PREFIX:line="39" PREFIX:column="16">RESET</name></expr></argument>, <argument><expr><name PREFIX:line="39" PREFIX:column="23">HIGH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name PREFIX:line="40" PREFIX:column="3">delay</name><argument_list PREFIX:line="40" PREFIX:column="8">(<argument><expr PREFIX:line="40" PREFIX:column="9">10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name PREFIX:line="41" PREFIX:column="3">digitalWrite</name><argument_list PREFIX:line="41" PREFIX:column="15">(<argument><expr><name PREFIX:line="41" PREFIX:column="16">RESET</name></expr></argument>, <argument><expr><name PREFIX:line="41" PREFIX:column="23">LOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name PREFIX:line="42" PREFIX:column="3">delay</name><argument_list PREFIX:line="42" PREFIX:column="8">(<argument><expr PREFIX:line="42" PREFIX:column="9">10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name PREFIX:line="43" PREFIX:column="3">digitalWrite</name><argument_list PREFIX:line="43" PREFIX:column="15">(<argument><expr><name PREFIX:line="43" PREFIX:column="16">RESET</name></expr></argument>, <argument><expr><name PREFIX:line="43" PREFIX:column="23">HIGH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name PREFIX:line="44" PREFIX:column="3">delay</name><argument_list PREFIX:line="44" PREFIX:column="8">(<argument><expr PREFIX:line="44" PREFIX:column="9">10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif PREFIX:line="45" PREFIX:column="1">#<cpp:directive PREFIX:line="45" PREFIX:column="2">endif</cpp:directive></cpp:endif>
  
  
  <comment type="line" PREFIX:line="48" PREFIX:column="3">// initialize SPI for the dSPIN chip's needs:</comment>
  <comment type="line" PREFIX:line="49" PREFIX:column="3">// most significant bit first,</comment>
  <comment type="line" PREFIX:line="50" PREFIX:column="3">// SPI clock not to exceed 5MHz,</comment>
  <comment type="line" PREFIX:line="51" PREFIX:column="3">// SPI_MODE3 (clock idle high, latch data on rising edge of clock)</comment>
  <expr_stmt><expr><call><name><name PREFIX:line="52" PREFIX:column="3">SPI</name>.<name PREFIX:line="52" PREFIX:column="7">begin</name></name><argument_list PREFIX:line="52" PREFIX:column="12">()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name PREFIX:line="53" PREFIX:column="3">SPI</name>.<name PREFIX:line="53" PREFIX:column="7">setBitOrder</name></name><argument_list PREFIX:line="53" PREFIX:column="18">(<argument><expr><name PREFIX:line="53" PREFIX:column="19">MSBFIRST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name PREFIX:line="54" PREFIX:column="3">SPI</name>.<name PREFIX:line="54" PREFIX:column="7">setClockDivider</name></name><argument_list PREFIX:line="54" PREFIX:column="22">(<argument><expr><name PREFIX:line="54" PREFIX:column="23">SPI_CLOCK_DIV16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line" PREFIX:line="54" PREFIX:column="41">// or 2, 8, 16, 32, 64</comment>
  <expr_stmt><expr><call><name><name PREFIX:line="55" PREFIX:column="3">SPI</name>.<name PREFIX:line="55" PREFIX:column="7">setDataMode</name></name><argument_list PREFIX:line="55" PREFIX:column="18">(<argument><expr><name PREFIX:line="55" PREFIX:column="19">SPI_MODE3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="line" PREFIX:line="57" PREFIX:column="3">// First things first: let's check communications. The CONFIG register should</comment>
  <comment type="line" PREFIX:line="58" PREFIX:column="3">// power up to 0x2E88, so we can use that to check the communications.</comment>
  <if PREFIX:line="59" PREFIX:column="3">if <condition PREFIX:line="59" PREFIX:column="6">(<expr><call><name PREFIX:line="59" PREFIX:column="7">GetParam</name><argument_list PREFIX:line="59" PREFIX:column="15">(<argument><expr><name PREFIX:line="59" PREFIX:column="16">CONFIG</name></expr></argument>)</argument_list></call> == 0x2E88</expr>)</condition><then><block PREFIX:line="59" PREFIX:column="34">{
    <comment type="line" PREFIX:line="60" PREFIX:column="5">//Serial.println('good to go');</comment>
  }</block></then>
  <else PREFIX:line="62" PREFIX:column="3">else<block PREFIX:line="62" PREFIX:column="7">{
    <comment type="line" PREFIX:line="63" PREFIX:column="5">//Serial.println('Comm issue');</comment>
  }</block></else></if>

<cpp:if PREFIX:line="66" PREFIX:column="1">#<cpp:directive PREFIX:line="66" PREFIX:column="2">if</cpp:directive>  <expr PREFIX:line="66" PREFIX:column="6">(<name PREFIX:line="66" PREFIX:column="7">ENABLE_RESET_PIN</name> == 0)</expr></cpp:if> 
  <expr_stmt><expr><call><name PREFIX:line="67" PREFIX:column="3">resetDev</name><argument_list PREFIX:line="67" PREFIX:column="11">()</argument_list></call></expr>;</expr_stmt>
<cpp:endif PREFIX:line="68" PREFIX:column="1">#<cpp:directive PREFIX:line="68" PREFIX:column="2">endif</cpp:directive></cpp:endif>
  <comment type="line" PREFIX:line="69" PREFIX:column="3">// First, let's set the step mode register:</comment>
  <comment type="line" PREFIX:line="70" PREFIX:column="3">// - SYNC_EN controls whether the BUSY/SYNC pin reflects the step</comment>
  <comment type="line" PREFIX:line="71" PREFIX:column="3">// frequency or the BUSY status of the chip. We want it to be the BUSY</comment>
  <comment type="line" PREFIX:line="72" PREFIX:column="3">// status.</comment>
  <comment type="line" PREFIX:line="73" PREFIX:column="3">// - STEP_SEL_x is the microstepping rate- we'll go full step.</comment>
  <comment type="line" PREFIX:line="74" PREFIX:column="3">// - SYNC_SEL_x is the ratio of (micro)steps to toggles on the</comment>
  <comment type="line" PREFIX:line="75" PREFIX:column="3">// BUSY/SYNC pin (when that pin is used for SYNC). Make it 1:1, despite</comment>
  <comment type="line" PREFIX:line="76" PREFIX:column="3">// not using that pin.</comment>
  <comment type="line" PREFIX:line="77" PREFIX:column="3">//SetParam(STEP_MODE, !SYNC_EN | STEP_SEL_1 | SYNC_SEL_1);</comment>
  
  
  <expr_stmt><expr><call><name PREFIX:line="80" PREFIX:column="3">SetParam</name><argument_list PREFIX:line="80" PREFIX:column="11">(<argument><expr><name PREFIX:line="80" PREFIX:column="12">KVAL_RUN</name></expr></argument>, <argument><expr><name PREFIX:line="80" PREFIX:column="22">k_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name PREFIX:line="81" PREFIX:column="3">SetParam</name><argument_list PREFIX:line="81" PREFIX:column="11">(<argument><expr><name PREFIX:line="81" PREFIX:column="12">KVAL_ACC</name></expr></argument>, <argument><expr><name PREFIX:line="81" PREFIX:column="22">k_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name PREFIX:line="82" PREFIX:column="3">SetParam</name><argument_list PREFIX:line="82" PREFIX:column="11">(<argument><expr><name PREFIX:line="82" PREFIX:column="12">KVAL_DEC</name></expr></argument>, <argument><expr><name PREFIX:line="82" PREFIX:column="22">k_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name PREFIX:line="83" PREFIX:column="3">SetParam</name><argument_list PREFIX:line="83" PREFIX:column="11">(<argument><expr><name PREFIX:line="83" PREFIX:column="12">KVAL_HOLD</name></expr></argument>, <argument><expr><name PREFIX:line="83" PREFIX:column="23">k_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="line" PREFIX:line="85" PREFIX:column="3">// Set up the CONFIG register as follows:</comment>
  <comment type="line" PREFIX:line="86" PREFIX:column="3">// PWM frequency divisor = 1</comment>
  <comment type="line" PREFIX:line="87" PREFIX:column="3">// PWM frequency multiplier = 2 (62.5kHz PWM frequency)</comment>
  <comment type="line" PREFIX:line="88" PREFIX:column="3">// Slew rate is 290V/us</comment>
  <comment type="line" PREFIX:line="89" PREFIX:column="3">// Do NOT shut down bridges on overcurrent</comment>
  <comment type="line" PREFIX:line="90" PREFIX:column="3">// Disable motor voltage compensation</comment>
  <comment type="line" PREFIX:line="91" PREFIX:column="3">// Hard stop on switch low</comment>
  <comment type="line" PREFIX:line="92" PREFIX:column="3">// 16MHz internal oscillator, nothing on output</comment>
  <expr_stmt><expr><call><name PREFIX:line="93" PREFIX:column="3">SetParam</name><argument_list PREFIX:line="93" PREFIX:column="11">(<argument><expr><name PREFIX:line="93" PREFIX:column="12">CONFIG</name></expr></argument>, <argument><expr><name PREFIX:line="93" PREFIX:column="20">CONFIG_PWM_DIV_1</name> | <name PREFIX:line="93" PREFIX:column="39">CONFIG_PWM_MUL_2</name> | <name PREFIX:line="93" PREFIX:column="58">CONFIG_SR_290V_us</name>| <name PREFIX:line="93" PREFIX:column="77">CONFIG_OC_SD_DISABLE</name> | <name PREFIX:line="93" PREFIX:column="100">CONFIG_VS_COMP_DISABLE</name> | <name PREFIX:line="93" PREFIX:column="125">CONFIG_SW_HARD_STOP</name> | <name PREFIX:line="93" PREFIX:column="147">CONFIG_INT_16MHZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line" PREFIX:line="94" PREFIX:column="3">// Configure the RUN KVAL. This defines the duty cycle of the PWM of the bridges</comment>
  <comment type="line" PREFIX:line="95" PREFIX:column="3">// during running. 0xFF means that they are essentially NOT PWMed during run; this</comment>
  <comment type="line" PREFIX:line="96" PREFIX:column="3">// MAY result in more power being dissipated than you actually need for the task.</comment>
  <comment type="line" PREFIX:line="97" PREFIX:column="3">// Setting this value too low may result in failure to turn.</comment>
  <comment type="line" PREFIX:line="98" PREFIX:column="3">// There are ACC, DEC, and HOLD KVAL registers as well; you may need to play with</comment>
  <comment type="line" PREFIX:line="99" PREFIX:column="3">// those values to get acceptable performance for a given application.</comment>
  <comment type="line" PREFIX:line="100" PREFIX:column="3">//SetParam(KVAL_RUN, 0xFF);</comment>
  <comment type="line" PREFIX:line="101" PREFIX:column="3">// Calling GetStatus() clears the UVLO bit in the status register, which is set by</comment>
  <comment type="line" PREFIX:line="102" PREFIX:column="3">// default on power-up. The driver may not run without that bit cleared by this</comment>
  <comment type="line" PREFIX:line="103" PREFIX:column="3">// read operation.</comment>
  <expr_stmt><expr><call><name PREFIX:line="104" PREFIX:column="3">getStatus</name><argument_list PREFIX:line="104" PREFIX:column="12">()</argument_list></call></expr>;</expr_stmt>
  
  <expr_stmt><expr><call><name PREFIX:line="106" PREFIX:column="3">hardStop</name><argument_list PREFIX:line="106" PREFIX:column="11">()</argument_list></call></expr>;</expr_stmt> <comment type="line" PREFIX:line="106" PREFIX:column="15">//engage motors</comment>
}</block></function>

<function><type><name PREFIX:line="109" PREFIX:column="1">boolean</name></type> <name><name PREFIX:line="109" PREFIX:column="9">L6470</name>::<name PREFIX:line="109" PREFIX:column="16">isBusy</name></name><parameter_list PREFIX:line="109" PREFIX:column="22">()</parameter_list><block PREFIX:line="109" PREFIX:column="24">{
  <decl_stmt><decl><type><name PREFIX:line="110" PREFIX:column="3">int</name></type> <name PREFIX:line="110" PREFIX:column="7">status</name> <init PREFIX:line="110" PREFIX:column="14">= <expr><call><name PREFIX:line="110" PREFIX:column="16">getStatus</name><argument_list PREFIX:line="110" PREFIX:column="25">()</argument_list></call></expr></init></decl>;</decl_stmt>
  <return PREFIX:line="111" PREFIX:column="3">return <expr PREFIX:line="111" PREFIX:column="10">!((<name PREFIX:line="111" PREFIX:column="13">status</name> &gt;&gt; 1) &amp; 0b1)</expr>;</return>
}</block></function>

<function><type><name PREFIX:line="114" PREFIX:column="1">void</name></type> <name><name PREFIX:line="114" PREFIX:column="6">L6470</name>::<name PREFIX:line="114" PREFIX:column="13">setMicroSteps</name></name><parameter_list PREFIX:line="114" PREFIX:column="26">(<param><decl><type><name PREFIX:line="114" PREFIX:column="27">int</name></type> <name PREFIX:line="114" PREFIX:column="31">microSteps</name></decl></param>)</parameter_list><block PREFIX:line="114" PREFIX:column="42">{
  <decl_stmt><decl><type><name PREFIX:line="115" PREFIX:column="3">byte</name></type> <name PREFIX:line="115" PREFIX:column="8">stepVal</name> <init PREFIX:line="115" PREFIX:column="16">= <expr PREFIX:line="115" PREFIX:column="18">0</expr></init></decl>;</decl_stmt>
  
  <for PREFIX:line="117" PREFIX:column="3">for(<init><expr><name PREFIX:line="117" PREFIX:column="7">stepVal</name> = 0</expr>;</init> <condition><expr><name PREFIX:line="117" PREFIX:column="20">stepVal</name> &lt; 8</expr>;</condition> <incr><expr><name PREFIX:line="117" PREFIX:column="33">stepVal</name>++</expr></incr>)<block PREFIX:line="117" PREFIX:column="43">{
    <if PREFIX:line="118" PREFIX:column="5">if<condition PREFIX:line="118" PREFIX:column="7">(<expr><name PREFIX:line="118" PREFIX:column="8">microSteps</name> == 1</expr>)</condition><then PREFIX:line="118" PREFIX:column="24"> <break PREFIX:line="118" PREFIX:column="25">break;</break></then></if>
    <expr_stmt><expr><name PREFIX:line="119" PREFIX:column="5">microSteps</name> = <name PREFIX:line="119" PREFIX:column="18">microSteps</name> &gt;&gt; 1</expr>;</expr_stmt>
  }</block></for>

  <expr_stmt><expr><call><name PREFIX:line="122" PREFIX:column="3">SetParam</name><argument_list PREFIX:line="122" PREFIX:column="11">(<argument><expr><name PREFIX:line="122" PREFIX:column="12">STEP_MODE</name></expr></argument>, <argument><expr PREFIX:line="122" PREFIX:column="23">!<name PREFIX:line="122" PREFIX:column="24">SYNC_EN</name> | <name PREFIX:line="122" PREFIX:column="34">stepVal</name> | <name PREFIX:line="122" PREFIX:column="44">SYNC_SEL_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name PREFIX:line="125" PREFIX:column="1">void</name></type> <name><name PREFIX:line="125" PREFIX:column="6">L6470</name>::<name PREFIX:line="125" PREFIX:column="13">setThresholdSpeed</name></name><parameter_list PREFIX:line="125" PREFIX:column="30">(<param><decl><type><name PREFIX:line="125" PREFIX:column="31">float</name></type> <name PREFIX:line="125" PREFIX:column="37">thresholdSpeed</name></decl></param>)</parameter_list><block PREFIX:line="125" PREFIX:column="52">{
  <comment type="line" PREFIX:line="126" PREFIX:column="3">// Configure the FS_SPD register- this is the speed at which the driver ceases</comment>
  <comment type="line" PREFIX:line="127" PREFIX:column="3">// microstepping and goes to full stepping. FSCalc() converts a value in steps/s</comment>
  <comment type="line" PREFIX:line="128" PREFIX:column="3">// to a value suitable for this register; to disable full-step switching, you</comment>
  <comment type="line" PREFIX:line="129" PREFIX:column="3">// can pass 0x3FF to this register.</comment>
  
  <if PREFIX:line="131" PREFIX:column="3">if<condition PREFIX:line="131" PREFIX:column="5">(<expr><name PREFIX:line="131" PREFIX:column="6">thresholdSpeed</name> == 0.0</expr>)</condition><then><block PREFIX:line="131" PREFIX:column="28">{
    <expr_stmt><expr><call><name PREFIX:line="132" PREFIX:column="5">SetParam</name><argument_list PREFIX:line="132" PREFIX:column="13">(<argument><expr><name PREFIX:line="132" PREFIX:column="14">FS_SPD</name></expr></argument>, <argument><expr PREFIX:line="132" PREFIX:column="22">0x3FF</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else PREFIX:line="134" PREFIX:column="3">else<block PREFIX:line="134" PREFIX:column="7">{
    <expr_stmt><expr><call><name PREFIX:line="135" PREFIX:column="5">SetParam</name><argument_list PREFIX:line="135" PREFIX:column="13">(<argument><expr><name PREFIX:line="135" PREFIX:column="14">FS_SPD</name></expr></argument>, <argument><expr><call><name PREFIX:line="135" PREFIX:column="22">FSCalc</name><argument_list PREFIX:line="135" PREFIX:column="28">(<argument><expr><name PREFIX:line="135" PREFIX:column="29">thresholdSpeed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>	
  }</block></else></if>
}</block></function>


<function><type><name PREFIX:line="140" PREFIX:column="1">void</name></type> <name><name PREFIX:line="140" PREFIX:column="6">L6470</name>::<name PREFIX:line="140" PREFIX:column="13">setCurrent</name></name><parameter_list PREFIX:line="140" PREFIX:column="23">(<param><decl><type><name PREFIX:line="140" PREFIX:column="24">int</name></type> <name PREFIX:line="140" PREFIX:column="28">current</name></decl></param>)</parameter_list><block PREFIX:line="140" PREFIX:column="36">{}</block></function>



<function><type><name PREFIX:line="144" PREFIX:column="1">void</name></type> <name><name PREFIX:line="144" PREFIX:column="6">L6470</name>::<name PREFIX:line="144" PREFIX:column="13">setMaxSpeed</name></name><parameter_list PREFIX:line="144" PREFIX:column="24">(<param><decl><type><name PREFIX:line="144" PREFIX:column="25">int</name></type> <name PREFIX:line="144" PREFIX:column="29">speed</name></decl></param>)</parameter_list><block PREFIX:line="144" PREFIX:column="35">{
  <comment type="line" PREFIX:line="145" PREFIX:column="3">// Configure the MAX_SPEED register- this is the maximum number of (micro)steps per</comment>
  <comment type="line" PREFIX:line="146" PREFIX:column="3">// second allowed. You'll want to mess around with your desired application to see</comment>
  <comment type="line" PREFIX:line="147" PREFIX:column="3">// how far you can push it before the motor starts to slip. The ACTUAL parameter</comment>
  <comment type="line" PREFIX:line="148" PREFIX:column="3">// passed to this function is in steps/tick; MaxSpdCalc() will convert a number of</comment>
  <comment type="line" PREFIX:line="149" PREFIX:column="3">// steps/s into an appropriate value for this function. Note that for any move or</comment>
  <comment type="line" PREFIX:line="150" PREFIX:column="3">// goto type function where no speed is specified, this value will be used.</comment>
  <expr_stmt><expr><call><name PREFIX:line="151" PREFIX:column="3">SetParam</name><argument_list PREFIX:line="151" PREFIX:column="11">(<argument><expr><name PREFIX:line="151" PREFIX:column="12">MAX_SPEED</name></expr></argument>, <argument><expr><call><name PREFIX:line="151" PREFIX:column="23">MaxSpdCalc</name><argument_list PREFIX:line="151" PREFIX:column="33">(<argument><expr><name PREFIX:line="151" PREFIX:column="34">speed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><name PREFIX:line="155" PREFIX:column="1">void</name></type> <name><name PREFIX:line="155" PREFIX:column="6">L6470</name>::<name PREFIX:line="155" PREFIX:column="13">setMinSpeed</name></name><parameter_list PREFIX:line="155" PREFIX:column="24">(<param><decl><type><name PREFIX:line="155" PREFIX:column="25">int</name></type> <name PREFIX:line="155" PREFIX:column="29">speed</name></decl></param>)</parameter_list><block PREFIX:line="155" PREFIX:column="35">{
  <comment type="line" PREFIX:line="156" PREFIX:column="3">// Configure the MAX_SPEED register- this is the maximum number of (micro)steps per</comment>
  <comment type="line" PREFIX:line="157" PREFIX:column="3">// second allowed. You'll want to mess around with your desired application to see</comment>
  <comment type="line" PREFIX:line="158" PREFIX:column="3">// how far you can push it before the motor starts to slip. The ACTUAL parameter</comment>
  <comment type="line" PREFIX:line="159" PREFIX:column="3">// passed to this function is in steps/tick; MaxSpdCalc() will convert a number of</comment>
  <comment type="line" PREFIX:line="160" PREFIX:column="3">// steps/s into an appropriate value for this function. Note that for any move or</comment>
  <comment type="line" PREFIX:line="161" PREFIX:column="3">// goto type function where no speed is specified, this value will be used.</comment>
  <expr_stmt><expr><call><name PREFIX:line="162" PREFIX:column="3">SetParam</name><argument_list PREFIX:line="162" PREFIX:column="11">(<argument><expr><name PREFIX:line="162" PREFIX:column="12">MIN_SPEED</name></expr></argument>, <argument><expr><call><name PREFIX:line="162" PREFIX:column="23">MinSpdCalc</name><argument_list PREFIX:line="162" PREFIX:column="33">(<argument><expr><name PREFIX:line="162" PREFIX:column="34">speed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>




<function><type><name PREFIX:line="168" PREFIX:column="1">void</name></type> <name><name PREFIX:line="168" PREFIX:column="6">L6470</name>::<name PREFIX:line="168" PREFIX:column="13">setAcc</name></name><parameter_list PREFIX:line="168" PREFIX:column="19">(<param><decl><type><name PREFIX:line="168" PREFIX:column="20">float</name></type> <name PREFIX:line="168" PREFIX:column="26">acceleration</name></decl></param>)</parameter_list><block PREFIX:line="168" PREFIX:column="39">{
  <comment type="line" PREFIX:line="169" PREFIX:column="3">// Configure the acceleration rate, in steps/tick/tick. There is also a DEC register;</comment>
  <comment type="line" PREFIX:line="170" PREFIX:column="3">// both of them have a function (AccCalc() and DecCalc() respectively) that convert</comment>
  <comment type="line" PREFIX:line="171" PREFIX:column="3">// from steps/s/s into the appropriate value for the register. Writing ACC to 0xfff</comment>
  <comment type="line" PREFIX:line="172" PREFIX:column="3">// sets the acceleration and deceleration to 'infinite' (or as near as the driver can</comment>
  <comment type="line" PREFIX:line="173" PREFIX:column="3">// manage). If ACC is set to 0xfff, DEC is ignored. To get infinite deceleration</comment>
  <comment type="line" PREFIX:line="174" PREFIX:column="3">// without infinite acceleration, only hard stop will work.</comment>
  <decl_stmt><decl><type><name PREFIX:line="175" PREFIX:column="3">unknowntype</name> <name PREFIX:line="175" PREFIX:column="15">long</name></type> <name PREFIX:line="175" PREFIX:column="20">accelerationBYTES</name> <init PREFIX:line="175" PREFIX:column="38">= <expr><call><name PREFIX:line="175" PREFIX:column="40">AccCalc</name><argument_list PREFIX:line="175" PREFIX:column="47">(<argument><expr><name PREFIX:line="175" PREFIX:column="48">acceleration</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name PREFIX:line="176" PREFIX:column="3">SetParam</name><argument_list PREFIX:line="176" PREFIX:column="11">(<argument><expr><name PREFIX:line="176" PREFIX:column="12">ACC</name></expr></argument>, <argument><expr><name PREFIX:line="176" PREFIX:column="17">accelerationBYTES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><name PREFIX:line="180" PREFIX:column="1">void</name></type> <name><name PREFIX:line="180" PREFIX:column="6">L6470</name>::<name PREFIX:line="180" PREFIX:column="13">setDec</name></name><parameter_list PREFIX:line="180" PREFIX:column="19">(<param><decl><type><name PREFIX:line="180" PREFIX:column="20">float</name></type> <name PREFIX:line="180" PREFIX:column="26">deceleration</name></decl></param>)</parameter_list><block PREFIX:line="180" PREFIX:column="39">{
  <decl_stmt><decl><type><name PREFIX:line="181" PREFIX:column="3">unknowntype</name> <name PREFIX:line="181" PREFIX:column="15">long</name></type> <name PREFIX:line="181" PREFIX:column="20">decelerationBYTES</name> <init PREFIX:line="181" PREFIX:column="38">= <expr><call><name PREFIX:line="181" PREFIX:column="40">DecCalc</name><argument_list PREFIX:line="181" PREFIX:column="47">(<argument><expr><name PREFIX:line="181" PREFIX:column="48">deceleration</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name PREFIX:line="182" PREFIX:column="3">SetParam</name><argument_list PREFIX:line="182" PREFIX:column="11">(<argument><expr><name PREFIX:line="182" PREFIX:column="12">DEC</name></expr></argument>, <argument><expr><name PREFIX:line="182" PREFIX:column="17">decelerationBYTES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><name PREFIX:line="186" PREFIX:column="1">long</name></type> <name><name PREFIX:line="186" PREFIX:column="6">L6470</name>::<name PREFIX:line="186" PREFIX:column="13">getPos</name></name><parameter_list PREFIX:line="186" PREFIX:column="19">()</parameter_list><block PREFIX:line="186" PREFIX:column="21">{
  <decl_stmt><decl><type><name PREFIX:line="187" PREFIX:column="3">unknowntype</name> <name PREFIX:line="187" PREFIX:column="15">long</name></type> <name PREFIX:line="187" PREFIX:column="20">position</name> <init PREFIX:line="187" PREFIX:column="29">= <expr><call><name PREFIX:line="187" PREFIX:column="31">GetParam</name><argument_list PREFIX:line="187" PREFIX:column="39">(<argument><expr><name PREFIX:line="187" PREFIX:column="40">ABS_POS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return PREFIX:line="188" PREFIX:column="3">return <expr><call><name PREFIX:line="188" PREFIX:column="10">convert</name><argument_list PREFIX:line="188" PREFIX:column="17">(<argument><expr><name PREFIX:line="188" PREFIX:column="18">position</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name PREFIX:line="191" PREFIX:column="1">float</name></type> <name><name PREFIX:line="191" PREFIX:column="7">L6470</name>::<name PREFIX:line="191" PREFIX:column="14">getSpeed</name></name><parameter_list PREFIX:line="191" PREFIX:column="22">()</parameter_list><block PREFIX:line="191" PREFIX:column="24">{
  <comment type="block" PREFIX:line="192" PREFIX:column="3">/*
  SPEED
  The SPEED register contains the current motor speed, expressed in step/tick (format unknowntype fixed point 0.28).
  In order to convert the SPEED value in step/s the following formula can be used:
  Equation 4
  where SPEED is the integer number stored into the register and tick is 250 ns.
  The available range is from 0 to 15625 step/s with a resolution of 0.015 step/s.
  Note: The range effectively available to the user is limited by the MAX_SPEED parameter.
  */</comment>
  
  <return PREFIX:line="202" PREFIX:column="3">return <expr PREFIX:line="202" PREFIX:column="10">(<name PREFIX:line="202" PREFIX:column="11">float</name>) <call><name PREFIX:line="202" PREFIX:column="18">GetParam</name><argument_list PREFIX:line="202" PREFIX:column="26">(<argument><expr><name PREFIX:line="202" PREFIX:column="27">SPEED</name></expr></argument>)</argument_list></call></expr>;</return>
  <comment type="line" PREFIX:line="203" PREFIX:column="3">//return (float) speed * pow(8, -22);</comment>
  <comment type="line" PREFIX:line="204" PREFIX:column="3">//return FSCalc(speed); NEEDS FIX</comment>
}</block></function>


<function><type><name PREFIX:line="208" PREFIX:column="1">void</name></type> <name><name PREFIX:line="208" PREFIX:column="6">L6470</name>::<name PREFIX:line="208" PREFIX:column="13">setOverCurrent</name></name><parameter_list PREFIX:line="208" PREFIX:column="27">(<param><decl><type><name PREFIX:line="208" PREFIX:column="28">unknowntype</name> <name PREFIX:line="208" PREFIX:column="40">int</name></type> <name PREFIX:line="208" PREFIX:column="44">ma_current</name></decl></param>)</parameter_list><block PREFIX:line="208" PREFIX:column="55">{
  <comment type="line" PREFIX:line="209" PREFIX:column="3">// Configure the overcurrent detection threshold.</comment>
  <decl_stmt><decl><type><name PREFIX:line="210" PREFIX:column="3">byte</name></type> <name PREFIX:line="210" PREFIX:column="8">OCValue</name> <init PREFIX:line="210" PREFIX:column="16">= <expr><call><name PREFIX:line="210" PREFIX:column="18">floor</name><argument_list PREFIX:line="210" PREFIX:column="23">(<argument><expr><name PREFIX:line="210" PREFIX:column="24">ma_current</name> / 375</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if PREFIX:line="211" PREFIX:column="3">if<condition PREFIX:line="211" PREFIX:column="5">(<expr><name PREFIX:line="211" PREFIX:column="6">OCValue</name> &gt; 0x0F</expr>)</condition><then><expr_stmt><expr><name PREFIX:line="211" PREFIX:column="21">OCValue</name> = 0x0F</expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name PREFIX:line="212" PREFIX:column="3">SetParam</name><argument_list PREFIX:line="212" PREFIX:column="11">(<argument><expr><name PREFIX:line="212" PREFIX:column="12">OCD_TH</name></expr></argument>, <argument><expr><name PREFIX:line="212" PREFIX:column="20">OCValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name PREFIX:line="215" PREFIX:column="1">void</name></type> <name><name PREFIX:line="215" PREFIX:column="6">L6470</name>::<name PREFIX:line="215" PREFIX:column="13">setStallCurrent</name></name><parameter_list PREFIX:line="215" PREFIX:column="28">(<param><decl><type><name PREFIX:line="215" PREFIX:column="29">float</name></type> <name PREFIX:line="215" PREFIX:column="35">ma_current</name></decl></param>)</parameter_list><block PREFIX:line="215" PREFIX:column="46">{
  <decl_stmt><decl><type><name PREFIX:line="216" PREFIX:column="3">byte</name></type> <name PREFIX:line="216" PREFIX:column="8">STHValue</name> <init PREFIX:line="216" PREFIX:column="17">= <expr PREFIX:line="216" PREFIX:column="19">(<name PREFIX:line="216" PREFIX:column="20">byte</name>)<call><name PREFIX:line="216" PREFIX:column="25">floor</name><argument_list PREFIX:line="216" PREFIX:column="30">(<argument><expr><name PREFIX:line="216" PREFIX:column="31">ma_current</name> / 31.25</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if PREFIX:line="217" PREFIX:column="3">if<condition PREFIX:line="217" PREFIX:column="5">(<expr><name PREFIX:line="217" PREFIX:column="6">STHValue</name> &gt; 0x80</expr>)</condition><then><expr_stmt><expr><name PREFIX:line="217" PREFIX:column="22">STHValue</name> = 0x80</expr>;</expr_stmt></then></if>
  <if PREFIX:line="218" PREFIX:column="3">if<condition PREFIX:line="218" PREFIX:column="5">(<expr><name PREFIX:line="218" PREFIX:column="6">STHValue</name> &lt; 0</expr>)</condition><then><expr_stmt><expr><name PREFIX:line="218" PREFIX:column="19">STHValue</name> = 0</expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name PREFIX:line="219" PREFIX:column="3">SetParam</name><argument_list PREFIX:line="219" PREFIX:column="11">(<argument><expr><name PREFIX:line="219" PREFIX:column="12">STALL_TH</name></expr></argument>, <argument><expr><name PREFIX:line="219" PREFIX:column="22">STHValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name PREFIX:line="222" PREFIX:column="1">void</name></type> <name><name PREFIX:line="222" PREFIX:column="6">L6470</name>::<name PREFIX:line="222" PREFIX:column="13">SetLowSpeedOpt</name></name><parameter_list PREFIX:line="222" PREFIX:column="27">(<param><decl><type><name PREFIX:line="222" PREFIX:column="28">boolean</name></type> <name PREFIX:line="222" PREFIX:column="36">enable</name></decl></param>)</parameter_list><block PREFIX:line="222" PREFIX:column="43">{
  <comment type="line" PREFIX:line="223" PREFIX:column="3">// Enable or disable the low-speed optimization option. If enabling,</comment>
  <comment type="line" PREFIX:line="224" PREFIX:column="3">// the other 12 bits of the register will be automatically zero.</comment>
  <comment type="line" PREFIX:line="225" PREFIX:column="3">// When disabling, the value will have to be explicitly written by</comment>
  <comment type="line" PREFIX:line="226" PREFIX:column="3">// the user with a SetParam() call. See the datasheet for further</comment>
  <comment type="line" PREFIX:line="227" PREFIX:column="3">// information about low-speed optimization.</comment>
  <expr_stmt><expr><call><name PREFIX:line="228" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="228" PREFIX:column="7">(<argument><expr><name PREFIX:line="228" PREFIX:column="8">SET_PARAM</name> | <name PREFIX:line="228" PREFIX:column="20">MIN_SPEED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if PREFIX:line="229" PREFIX:column="3">if <condition PREFIX:line="229" PREFIX:column="6">(<expr><name PREFIX:line="229" PREFIX:column="7">enable</name></expr>)</condition><then PREFIX:line="229" PREFIX:column="14"> <expr_stmt><expr><call><name PREFIX:line="229" PREFIX:column="15">Param</name><argument_list PREFIX:line="229" PREFIX:column="20">(<argument><expr PREFIX:line="229" PREFIX:column="21">0x1000</expr></argument>, <argument><expr PREFIX:line="229" PREFIX:column="29">13</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else PREFIX:line="230" PREFIX:column="3">else <expr_stmt><expr><call><name PREFIX:line="230" PREFIX:column="8">Param</name><argument_list PREFIX:line="230" PREFIX:column="13">(<argument><expr PREFIX:line="230" PREFIX:column="14">0</expr></argument>, <argument><expr PREFIX:line="230" PREFIX:column="17">13</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></function>


<function><type><name PREFIX:line="234" PREFIX:column="1">void</name></type> <name><name PREFIX:line="234" PREFIX:column="6">L6470</name>::<name PREFIX:line="234" PREFIX:column="13">run</name></name><parameter_list PREFIX:line="234" PREFIX:column="16">(<param><decl><type><name PREFIX:line="234" PREFIX:column="17">byte</name></type> <name PREFIX:line="234" PREFIX:column="22">dir</name></decl></param>, <param><decl><type><name PREFIX:line="234" PREFIX:column="27">float</name></type> <name PREFIX:line="234" PREFIX:column="33">spd</name></decl></param>)</parameter_list><block PREFIX:line="234" PREFIX:column="37">{
  <comment type="line" PREFIX:line="235" PREFIX:column="3">// RUN sets the motor spinning in a direction (defined by the ants</comment>
  <comment type="line" PREFIX:line="236" PREFIX:column="3">// FWD and REV). Maximum speed and minimum speed are defined</comment>
  <comment type="line" PREFIX:line="237" PREFIX:column="3">// by the MAX_SPEED and MIN_SPEED registers; exceeding the FS_SPD value</comment>
  <comment type="line" PREFIX:line="238" PREFIX:column="3">// will switch the device into full-step mode.</comment>
  <comment type="line" PREFIX:line="239" PREFIX:column="3">// The SpdCalc() function is provided to convert steps/s values into</comment>
  <comment type="line" PREFIX:line="240" PREFIX:column="3">// appropriate integer values for this function.</comment>
  <decl_stmt><decl><type><name PREFIX:line="241" PREFIX:column="3">unknowntype</name> <name PREFIX:line="241" PREFIX:column="15">long</name></type> <name PREFIX:line="241" PREFIX:column="20">speedVal</name> <init PREFIX:line="241" PREFIX:column="29">= <expr><call><name PREFIX:line="241" PREFIX:column="31">SpdCalc</name><argument_list PREFIX:line="241" PREFIX:column="38">(<argument><expr><name PREFIX:line="241" PREFIX:column="39">spd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  
  <expr_stmt><expr><call><name PREFIX:line="243" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="243" PREFIX:column="7">(<argument><expr><name PREFIX:line="243" PREFIX:column="8">RUN</name> | <name PREFIX:line="243" PREFIX:column="14">dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if PREFIX:line="244" PREFIX:column="3">if <condition PREFIX:line="244" PREFIX:column="6">(<expr><name PREFIX:line="244" PREFIX:column="7">speedVal</name> &gt; 0xFFFFF</expr>)</condition><then PREFIX:line="244" PREFIX:column="26"> <expr_stmt><expr><name PREFIX:line="244" PREFIX:column="27">speedVal</name> = 0xFFFFF</expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name PREFIX:line="245" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="245" PREFIX:column="7">(<argument><expr><call PREFIX:line="245" PREFIX:column="8">(<name PREFIX:line="245" PREFIX:column="9">byte</name>)<argument_list PREFIX:line="245" PREFIX:column="14">(<argument><expr><name PREFIX:line="245" PREFIX:column="15">speedVal</name> &gt;&gt; 16</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name PREFIX:line="246" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="246" PREFIX:column="7">(<argument><expr><call PREFIX:line="246" PREFIX:column="8">(<name PREFIX:line="246" PREFIX:column="9">byte</name>)<argument_list PREFIX:line="246" PREFIX:column="14">(<argument><expr><name PREFIX:line="246" PREFIX:column="15">speedVal</name> &gt;&gt; 8</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name PREFIX:line="247" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="247" PREFIX:column="7">(<argument><expr><call PREFIX:line="247" PREFIX:column="8">(<name PREFIX:line="247" PREFIX:column="9">byte</name>)<argument_list PREFIX:line="247" PREFIX:column="14">(<argument><expr><name PREFIX:line="247" PREFIX:column="15">speedVal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><name PREFIX:line="251" PREFIX:column="1">void</name></type> <name><name PREFIX:line="251" PREFIX:column="6">L6470</name>::<name PREFIX:line="251" PREFIX:column="13">Step_Clock</name></name><parameter_list PREFIX:line="251" PREFIX:column="23">(<param><decl><type><name PREFIX:line="251" PREFIX:column="24">byte</name></type> <name PREFIX:line="251" PREFIX:column="29">dir</name></decl></param>)</parameter_list><block PREFIX:line="251" PREFIX:column="33">{
  <comment type="line" PREFIX:line="252" PREFIX:column="3">// STEP_CLOCK puts the device in al step clocking mode. When active,</comment>
  <comment type="line" PREFIX:line="253" PREFIX:column="3">// pin 25, STCK, becomes the step clock for the device, and steps it in</comment>
  <comment type="line" PREFIX:line="254" PREFIX:column="3">// the direction (set by the FWD and REV ants) imposed by the call</comment>
  <comment type="line" PREFIX:line="255" PREFIX:column="3">// of this function. Motion commands (RUN, MOVE, etc) will cause the device</comment>
  <comment type="line" PREFIX:line="256" PREFIX:column="3">// to exit step clocking mode.</comment>
  <expr_stmt><expr><call><name PREFIX:line="257" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="257" PREFIX:column="7">(<argument><expr><name PREFIX:line="257" PREFIX:column="8">STEP_CLOCK</name> | <name PREFIX:line="257" PREFIX:column="21">dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name PREFIX:line="260" PREFIX:column="1">void</name></type> <name><name PREFIX:line="260" PREFIX:column="6">L6470</name>::<name PREFIX:line="260" PREFIX:column="13">move</name></name><parameter_list PREFIX:line="260" PREFIX:column="17">(<param><decl><type><name PREFIX:line="260" PREFIX:column="18">long</name></type> <name PREFIX:line="260" PREFIX:column="23">n_step</name></decl></param>)</parameter_list><block PREFIX:line="260" PREFIX:column="30">{
  <comment type="line" PREFIX:line="261" PREFIX:column="3">// MOVE will send the motor n_step steps (size based on step mode) in the</comment>
  <comment type="line" PREFIX:line="262" PREFIX:column="3">// direction imposed by dir (FWD or REV ants may be used). The motor</comment>
  <comment type="line" PREFIX:line="263" PREFIX:column="3">// will accelerate according the acceleration and deceleration curves, and</comment>
  <comment type="line" PREFIX:line="264" PREFIX:column="3">// will run at MAX_SPEED. Stepping mode will adhere to FS_SPD value, as well.</comment>
  
  <decl_stmt><decl><type><name PREFIX:line="266" PREFIX:column="3">byte</name></type> <name PREFIX:line="266" PREFIX:column="8">dir</name></decl>;</decl_stmt>
  
  <if PREFIX:line="268" PREFIX:column="3">if<condition PREFIX:line="268" PREFIX:column="5">(<expr><name PREFIX:line="268" PREFIX:column="6">n_step</name> &gt;= 0</expr>)</condition><then><block PREFIX:line="268" PREFIX:column="18">{
    <expr_stmt><expr><name PREFIX:line="269" PREFIX:column="5">dir</name> = <name PREFIX:line="269" PREFIX:column="11">FWD</name></expr>;</expr_stmt>
  }</block></then>
  <else PREFIX:line="271" PREFIX:column="3">else<block PREFIX:line="271" PREFIX:column="7">{
    <expr_stmt><expr><name PREFIX:line="272" PREFIX:column="5">dir</name> = <name PREFIX:line="272" PREFIX:column="11">REV</name></expr>;</expr_stmt>
  }</block></else></if>

  <decl_stmt><decl><type><name PREFIX:line="275" PREFIX:column="3">long</name></type> <name PREFIX:line="275" PREFIX:column="8">n_stepABS</name> <init PREFIX:line="275" PREFIX:column="18">= <expr><call><name PREFIX:line="275" PREFIX:column="20">abs</name><argument_list PREFIX:line="275" PREFIX:column="23">(<argument><expr><name PREFIX:line="275" PREFIX:column="24">n_step</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  
  <expr_stmt><expr><call><name PREFIX:line="277" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="277" PREFIX:column="7">(<argument><expr><name PREFIX:line="277" PREFIX:column="8">MOVE</name> | <name PREFIX:line="277" PREFIX:column="15">dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line" PREFIX:line="277" PREFIX:column="21">//set direction</comment>
  <if PREFIX:line="278" PREFIX:column="3">if <condition PREFIX:line="278" PREFIX:column="6">(<expr><name PREFIX:line="278" PREFIX:column="7">n_stepABS</name> &gt; 0x3FFFFF</expr>)</condition><then PREFIX:line="278" PREFIX:column="28"> <expr_stmt><expr><name PREFIX:line="278" PREFIX:column="29">n_step</name> = 0x3FFFFF</expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name PREFIX:line="279" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="279" PREFIX:column="7">(<argument><expr><call PREFIX:line="279" PREFIX:column="8">(<name PREFIX:line="279" PREFIX:column="9">byte</name>)<argument_list PREFIX:line="279" PREFIX:column="14">(<argument><expr><name PREFIX:line="279" PREFIX:column="15">n_stepABS</name> &gt;&gt; 16</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name PREFIX:line="280" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="280" PREFIX:column="7">(<argument><expr><call PREFIX:line="280" PREFIX:column="8">(<name PREFIX:line="280" PREFIX:column="9">byte</name>)<argument_list PREFIX:line="280" PREFIX:column="14">(<argument><expr><name PREFIX:line="280" PREFIX:column="15">n_stepABS</name> &gt;&gt; 8</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name PREFIX:line="281" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="281" PREFIX:column="7">(<argument><expr><call PREFIX:line="281" PREFIX:column="8">(<name PREFIX:line="281" PREFIX:column="9">byte</name>)<argument_list PREFIX:line="281" PREFIX:column="14">(<argument><expr><name PREFIX:line="281" PREFIX:column="15">n_stepABS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name PREFIX:line="284" PREFIX:column="1">void</name></type> <name><name PREFIX:line="284" PREFIX:column="6">L6470</name>::<name PREFIX:line="284" PREFIX:column="13">goTo</name></name><parameter_list PREFIX:line="284" PREFIX:column="17">(<param><decl><type><name PREFIX:line="284" PREFIX:column="18">long</name></type> <name PREFIX:line="284" PREFIX:column="23">pos</name></decl></param>)</parameter_list><block PREFIX:line="284" PREFIX:column="27">{
  <comment type="line" PREFIX:line="285" PREFIX:column="3">// GOTO operates much like MOVE, except it produces absolute motion instead</comment>
  <comment type="line" PREFIX:line="286" PREFIX:column="3">// of relative motion. The motor will be moved to the indicated position</comment>
  <comment type="line" PREFIX:line="287" PREFIX:column="3">// in the shortest possible fashion.</comment>
  
  <expr_stmt><expr><call><name PREFIX:line="289" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="289" PREFIX:column="7">(<argument><expr><name PREFIX:line="289" PREFIX:column="8">GOTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if PREFIX:line="290" PREFIX:column="3">if <condition PREFIX:line="290" PREFIX:column="6">(<expr><name PREFIX:line="290" PREFIX:column="7">pos</name> &gt; 0x3FFFFF</expr>)</condition><then PREFIX:line="290" PREFIX:column="22"> <expr_stmt><expr><name PREFIX:line="290" PREFIX:column="23">pos</name> = 0x3FFFFF</expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name PREFIX:line="291" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="291" PREFIX:column="7">(<argument><expr><call PREFIX:line="291" PREFIX:column="8">(<name PREFIX:line="291" PREFIX:column="9">byte</name>)<argument_list PREFIX:line="291" PREFIX:column="14">(<argument><expr><name PREFIX:line="291" PREFIX:column="15">pos</name> &gt;&gt; 16</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name PREFIX:line="292" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="292" PREFIX:column="7">(<argument><expr><call PREFIX:line="292" PREFIX:column="8">(<name PREFIX:line="292" PREFIX:column="9">byte</name>)<argument_list PREFIX:line="292" PREFIX:column="14">(<argument><expr><name PREFIX:line="292" PREFIX:column="15">pos</name> &gt;&gt; 8</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name PREFIX:line="293" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="293" PREFIX:column="7">(<argument><expr><call PREFIX:line="293" PREFIX:column="8">(<name PREFIX:line="293" PREFIX:column="9">byte</name>)<argument_list PREFIX:line="293" PREFIX:column="14">(<argument><expr><name PREFIX:line="293" PREFIX:column="15">pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><name PREFIX:line="297" PREFIX:column="1">void</name></type> <name><name PREFIX:line="297" PREFIX:column="6">L6470</name>::<name PREFIX:line="297" PREFIX:column="13">goTo_DIR</name></name><parameter_list PREFIX:line="297" PREFIX:column="21">(<param><decl><type><name PREFIX:line="297" PREFIX:column="22">byte</name></type> <name PREFIX:line="297" PREFIX:column="27">dir</name></decl></param>, <param><decl><type><name PREFIX:line="297" PREFIX:column="32">long</name></type> <name PREFIX:line="297" PREFIX:column="37">pos</name></decl></param>)</parameter_list><block PREFIX:line="297" PREFIX:column="41">{
  <comment type="line" PREFIX:line="298" PREFIX:column="3">// Same as GOTO, but with user rained rotational direction.</comment>
  
  <expr_stmt><expr><call><name PREFIX:line="300" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="300" PREFIX:column="7">(<argument><expr><name PREFIX:line="300" PREFIX:column="8">GOTO_DIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if PREFIX:line="301" PREFIX:column="3">if <condition PREFIX:line="301" PREFIX:column="6">(<expr><name PREFIX:line="301" PREFIX:column="7">pos</name> &gt; 0x3FFFFF</expr>)</condition><then PREFIX:line="301" PREFIX:column="22"> <expr_stmt><expr><name PREFIX:line="301" PREFIX:column="23">pos</name> = 0x3FFFFF</expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name PREFIX:line="302" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="302" PREFIX:column="7">(<argument><expr><call PREFIX:line="302" PREFIX:column="8">(<name PREFIX:line="302" PREFIX:column="9">byte</name>)<argument_list PREFIX:line="302" PREFIX:column="14">(<argument><expr><name PREFIX:line="302" PREFIX:column="15">pos</name> &gt;&gt; 16</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name PREFIX:line="303" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="303" PREFIX:column="7">(<argument><expr><call PREFIX:line="303" PREFIX:column="8">(<name PREFIX:line="303" PREFIX:column="9">byte</name>)<argument_list PREFIX:line="303" PREFIX:column="14">(<argument><expr><name PREFIX:line="303" PREFIX:column="15">pos</name> &gt;&gt; 8</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name PREFIX:line="304" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="304" PREFIX:column="7">(<argument><expr><call PREFIX:line="304" PREFIX:column="8">(<name PREFIX:line="304" PREFIX:column="9">byte</name>)<argument_list PREFIX:line="304" PREFIX:column="14">(<argument><expr><name PREFIX:line="304" PREFIX:column="15">pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name PREFIX:line="307" PREFIX:column="1">void</name></type> <name><name PREFIX:line="307" PREFIX:column="6">L6470</name>::<name PREFIX:line="307" PREFIX:column="13">goUntil</name></name><parameter_list PREFIX:line="307" PREFIX:column="20">(<param><decl><type><name PREFIX:line="307" PREFIX:column="21">byte</name></type> <name PREFIX:line="307" PREFIX:column="26">act</name></decl></param>, <param><decl><type><name PREFIX:line="307" PREFIX:column="31">byte</name></type> <name PREFIX:line="307" PREFIX:column="36">dir</name></decl></param>, <param><decl><type><name PREFIX:line="307" PREFIX:column="41">unknowntype</name> <name PREFIX:line="307" PREFIX:column="53">long</name></type> <name PREFIX:line="307" PREFIX:column="58">spd</name></decl></param>)</parameter_list><block PREFIX:line="307" PREFIX:column="62">{
  <comment type="line" PREFIX:line="308" PREFIX:column="3">// GoUntil will set the motor running with direction dir (REV or</comment>
  <comment type="line" PREFIX:line="309" PREFIX:column="3">// FWD) until a falling edge is detected on the SW pin. Depending</comment>
  <comment type="line" PREFIX:line="310" PREFIX:column="3">// on bit SW_MODE in CONFIG, either a hard stop or a soft stop is</comment>
  <comment type="line" PREFIX:line="311" PREFIX:column="3">// performed at the falling edge, and depending on the value of</comment>
  <comment type="line" PREFIX:line="312" PREFIX:column="3">// act (either RESET or COPY) the value in the ABS_POS register is</comment>
  <comment type="line" PREFIX:line="313" PREFIX:column="3">// either RESET to 0 or COPY-ed into the MARK register.</comment>
  <expr_stmt><expr><call><name PREFIX:line="314" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="314" PREFIX:column="7">(<argument><expr><name PREFIX:line="314" PREFIX:column="8">GO_UNTIL</name> | <name PREFIX:line="314" PREFIX:column="19">act</name> | <name PREFIX:line="314" PREFIX:column="25">dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if PREFIX:line="315" PREFIX:column="3">if <condition PREFIX:line="315" PREFIX:column="6">(<expr><name PREFIX:line="315" PREFIX:column="7">spd</name> &gt; 0x3FFFFF</expr>)</condition><then PREFIX:line="315" PREFIX:column="22"> <expr_stmt><expr><name PREFIX:line="315" PREFIX:column="23">spd</name> = 0x3FFFFF</expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name PREFIX:line="316" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="316" PREFIX:column="7">(<argument><expr><call PREFIX:line="316" PREFIX:column="8">(<name PREFIX:line="316" PREFIX:column="9">byte</name>)<argument_list PREFIX:line="316" PREFIX:column="14">(<argument><expr><name PREFIX:line="316" PREFIX:column="15">spd</name> &gt;&gt; 16</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name PREFIX:line="317" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="317" PREFIX:column="7">(<argument><expr><call PREFIX:line="317" PREFIX:column="8">(<name PREFIX:line="317" PREFIX:column="9">byte</name>)<argument_list PREFIX:line="317" PREFIX:column="14">(<argument><expr><name PREFIX:line="317" PREFIX:column="15">spd</name> &gt;&gt; 8</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name PREFIX:line="318" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="318" PREFIX:column="7">(<argument><expr><call PREFIX:line="318" PREFIX:column="8">(<name PREFIX:line="318" PREFIX:column="9">byte</name>)<argument_list PREFIX:line="318" PREFIX:column="14">(<argument><expr><name PREFIX:line="318" PREFIX:column="15">spd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name PREFIX:line="321" PREFIX:column="1">void</name></type> <name><name PREFIX:line="321" PREFIX:column="6">L6470</name>::<name PREFIX:line="321" PREFIX:column="13">releaseSW</name></name><parameter_list PREFIX:line="321" PREFIX:column="22">(<param><decl><type><name PREFIX:line="321" PREFIX:column="23">byte</name></type> <name PREFIX:line="321" PREFIX:column="28">act</name></decl></param>, <param><decl><type><name PREFIX:line="321" PREFIX:column="33">byte</name></type> <name PREFIX:line="321" PREFIX:column="38">dir</name></decl></param>)</parameter_list><block PREFIX:line="321" PREFIX:column="42">{
  <comment type="line" PREFIX:line="322" PREFIX:column="3">// Similar in nature to GoUntil, ReleaseSW produces motion at the</comment>
  <comment type="line" PREFIX:line="323" PREFIX:column="3">// higher of two speeds: the value in MIN_SPEED or 5 steps/s.</comment>
  <comment type="line" PREFIX:line="324" PREFIX:column="3">// The motor continues to run at this speed until a rising edge</comment>
  <comment type="line" PREFIX:line="325" PREFIX:column="3">// is detected on the switch input, then a hard stop is performed</comment>
  <comment type="line" PREFIX:line="326" PREFIX:column="3">// and the ABS_POS register is either COPY-ed into MARK or RESET to</comment>
  <comment type="line" PREFIX:line="327" PREFIX:column="3">// 0, depending on whether RESET or COPY was passed to the function</comment>
  <comment type="line" PREFIX:line="328" PREFIX:column="3">// for act.</comment>
  <expr_stmt><expr><call><name PREFIX:line="329" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="329" PREFIX:column="7">(<argument><expr><name PREFIX:line="329" PREFIX:column="8">RELEASE_SW</name> | <name PREFIX:line="329" PREFIX:column="21">act</name> | <name PREFIX:line="329" PREFIX:column="27">dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name PREFIX:line="332" PREFIX:column="1">void</name></type> <name><name PREFIX:line="332" PREFIX:column="6">L6470</name>::<name PREFIX:line="332" PREFIX:column="13">goHome</name></name><parameter_list PREFIX:line="332" PREFIX:column="19">()</parameter_list><block PREFIX:line="332" PREFIX:column="21">{
  <comment type="line" PREFIX:line="333" PREFIX:column="3">// GoHome is equivalent to GoTo(0), but requires less time to send.</comment>
  <comment type="line" PREFIX:line="334" PREFIX:column="3">// Note that no direction is provided; motion occurs through shortest</comment>
  <comment type="line" PREFIX:line="335" PREFIX:column="3">// path. If a direction is required, use GoTo_DIR().</comment>
  <expr_stmt><expr><call><name PREFIX:line="336" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="336" PREFIX:column="7">(<argument><expr><name PREFIX:line="336" PREFIX:column="8">GO_HOME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name PREFIX:line="339" PREFIX:column="1">void</name></type> <name><name PREFIX:line="339" PREFIX:column="6">L6470</name>::<name PREFIX:line="339" PREFIX:column="13">goMark</name></name><parameter_list PREFIX:line="339" PREFIX:column="19">()</parameter_list><block PREFIX:line="339" PREFIX:column="21">{
  <comment type="line" PREFIX:line="340" PREFIX:column="3">// GoMark is equivalent to GoTo(MARK), but requires less time to send.</comment>
  <comment type="line" PREFIX:line="341" PREFIX:column="3">// Note that no direction is provided; motion occurs through shortest</comment>
  <comment type="line" PREFIX:line="342" PREFIX:column="3">// path. If a direction is required, use GoTo_DIR().</comment>
  <expr_stmt><expr><call><name PREFIX:line="343" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="343" PREFIX:column="7">(<argument><expr><name PREFIX:line="343" PREFIX:column="8">GO_MARK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><name PREFIX:line="347" PREFIX:column="1">void</name></type> <name><name PREFIX:line="347" PREFIX:column="6">L6470</name>::<name PREFIX:line="347" PREFIX:column="13">setMark</name></name><parameter_list PREFIX:line="347" PREFIX:column="20">(<param><decl><type><name PREFIX:line="347" PREFIX:column="21">long</name></type> <name PREFIX:line="347" PREFIX:column="26">value</name></decl></param>)</parameter_list><block PREFIX:line="347" PREFIX:column="32">{

  <expr_stmt><expr><call><name PREFIX:line="349" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="349" PREFIX:column="7">(<argument><expr><name PREFIX:line="349" PREFIX:column="8">MARK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if PREFIX:line="350" PREFIX:column="3">if <condition PREFIX:line="350" PREFIX:column="6">(<expr><name PREFIX:line="350" PREFIX:column="7">value</name> &gt; 0x3FFFFF</expr>)</condition><then PREFIX:line="350" PREFIX:column="24"> <expr_stmt><expr><name PREFIX:line="350" PREFIX:column="25">value</name> = 0x3FFFFF</expr>;</expr_stmt></then></if>
  <if PREFIX:line="351" PREFIX:column="3">if <condition PREFIX:line="351" PREFIX:column="6">(<expr><name PREFIX:line="351" PREFIX:column="7">value</name> &lt; -0x3FFFFF</expr>)</condition><then PREFIX:line="351" PREFIX:column="25"> <expr_stmt><expr><name PREFIX:line="351" PREFIX:column="26">value</name> = -0x3FFFFF</expr>;</expr_stmt></then></if>
  
  
  <expr_stmt><expr><call><name PREFIX:line="354" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="354" PREFIX:column="7">(<argument><expr><call PREFIX:line="354" PREFIX:column="8">(<name PREFIX:line="354" PREFIX:column="9">byte</name>)<argument_list PREFIX:line="354" PREFIX:column="14">(<argument><expr><name PREFIX:line="354" PREFIX:column="15">value</name> &gt;&gt; 16</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name PREFIX:line="355" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="355" PREFIX:column="7">(<argument><expr><call PREFIX:line="355" PREFIX:column="8">(<name PREFIX:line="355" PREFIX:column="9">byte</name>)<argument_list PREFIX:line="355" PREFIX:column="14">(<argument><expr><name PREFIX:line="355" PREFIX:column="15">value</name> &gt;&gt; 8</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name PREFIX:line="356" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="356" PREFIX:column="7">(<argument><expr><call PREFIX:line="356" PREFIX:column="8">(<name PREFIX:line="356" PREFIX:column="9">byte</name>)<argument_list PREFIX:line="356" PREFIX:column="14">(<argument><expr><name PREFIX:line="356" PREFIX:column="15">value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><name PREFIX:line="360" PREFIX:column="1">void</name></type> <name><name PREFIX:line="360" PREFIX:column="6">L6470</name>::<name PREFIX:line="360" PREFIX:column="13">setMark</name></name><parameter_list PREFIX:line="360" PREFIX:column="20">()</parameter_list><block PREFIX:line="360" PREFIX:column="22">{
  <decl_stmt><decl><type><name PREFIX:line="361" PREFIX:column="3">long</name></type> <name PREFIX:line="361" PREFIX:column="8">value</name> <init PREFIX:line="361" PREFIX:column="14">= <expr><call><name PREFIX:line="361" PREFIX:column="16">getPos</name><argument_list PREFIX:line="361" PREFIX:column="22">()</argument_list></call></expr></init></decl>;</decl_stmt>
  
  <expr_stmt><expr><call><name PREFIX:line="363" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="363" PREFIX:column="7">(<argument><expr><name PREFIX:line="363" PREFIX:column="8">MARK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if PREFIX:line="364" PREFIX:column="3">if <condition PREFIX:line="364" PREFIX:column="6">(<expr><name PREFIX:line="364" PREFIX:column="7">value</name> &gt; 0x3FFFFF</expr>)</condition><then PREFIX:line="364" PREFIX:column="24"> <expr_stmt><expr><name PREFIX:line="364" PREFIX:column="25">value</name> = 0x3FFFFF</expr>;</expr_stmt></then></if>
  <if PREFIX:line="365" PREFIX:column="3">if <condition PREFIX:line="365" PREFIX:column="6">(<expr><name PREFIX:line="365" PREFIX:column="7">value</name> &lt; -0x3FFFFF</expr>)</condition><then PREFIX:line="365" PREFIX:column="25"> <expr_stmt><expr><name PREFIX:line="365" PREFIX:column="26">value</name> = -0x3FFFFF</expr>;</expr_stmt></then></if>
  
  
  <expr_stmt><expr><call><name PREFIX:line="368" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="368" PREFIX:column="7">(<argument><expr><call PREFIX:line="368" PREFIX:column="8">(<name PREFIX:line="368" PREFIX:column="9">byte</name>)<argument_list PREFIX:line="368" PREFIX:column="14">(<argument><expr><name PREFIX:line="368" PREFIX:column="15">value</name> &gt;&gt; 16</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name PREFIX:line="369" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="369" PREFIX:column="7">(<argument><expr><call PREFIX:line="369" PREFIX:column="8">(<name PREFIX:line="369" PREFIX:column="9">byte</name>)<argument_list PREFIX:line="369" PREFIX:column="14">(<argument><expr><name PREFIX:line="369" PREFIX:column="15">value</name> &gt;&gt; 8</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name PREFIX:line="370" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="370" PREFIX:column="7">(<argument><expr><call PREFIX:line="370" PREFIX:column="8">(<name PREFIX:line="370" PREFIX:column="9">byte</name>)<argument_list PREFIX:line="370" PREFIX:column="14">(<argument><expr><name PREFIX:line="370" PREFIX:column="15">value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name PREFIX:line="373" PREFIX:column="1">void</name></type> <name><name PREFIX:line="373" PREFIX:column="6">L6470</name>::<name PREFIX:line="373" PREFIX:column="13">setAsHome</name></name><parameter_list PREFIX:line="373" PREFIX:column="22">()</parameter_list><block PREFIX:line="373" PREFIX:column="24">{
  <comment type="line" PREFIX:line="374" PREFIX:column="3">// Sets the ABS_POS register to 0, effectively declaring the current</comment>
  <comment type="line" PREFIX:line="375" PREFIX:column="3">// position to be "HOME".</comment>
  <expr_stmt><expr><call><name PREFIX:line="376" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="376" PREFIX:column="7">(<argument><expr><name PREFIX:line="376" PREFIX:column="8">RESET_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name PREFIX:line="379" PREFIX:column="1">void</name></type> <name><name PREFIX:line="379" PREFIX:column="6">L6470</name>::<name PREFIX:line="379" PREFIX:column="13">resetDev</name></name><parameter_list PREFIX:line="379" PREFIX:column="21">()</parameter_list><block PREFIX:line="379" PREFIX:column="23">{
  <comment type="line" PREFIX:line="380" PREFIX:column="3">// Reset device to power up conditions. Equivalent to toggling the STBY</comment>
  <comment type="line" PREFIX:line="381" PREFIX:column="3">// pin or cycling power.</comment>
  <expr_stmt><expr><call><name PREFIX:line="382" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="382" PREFIX:column="7">(<argument><expr><name PREFIX:line="382" PREFIX:column="8">RESET_DEVICE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name PREFIX:line="385" PREFIX:column="1">void</name></type> <name><name PREFIX:line="385" PREFIX:column="6">L6470</name>::<name PREFIX:line="385" PREFIX:column="13">softStop</name></name><parameter_list PREFIX:line="385" PREFIX:column="21">()</parameter_list><block PREFIX:line="385" PREFIX:column="23">{
  <comment type="line" PREFIX:line="386" PREFIX:column="3">// Bring the motor to a halt using the deceleration curve.</comment>
  <expr_stmt><expr><call><name PREFIX:line="387" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="387" PREFIX:column="7">(<argument><expr><name PREFIX:line="387" PREFIX:column="8">SOFT_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name PREFIX:line="390" PREFIX:column="1">void</name></type> <name><name PREFIX:line="390" PREFIX:column="6">L6470</name>::<name PREFIX:line="390" PREFIX:column="13">hardStop</name></name><parameter_list PREFIX:line="390" PREFIX:column="21">()</parameter_list><block PREFIX:line="390" PREFIX:column="23">{
  <comment type="line" PREFIX:line="391" PREFIX:column="3">// Stop the motor right away. No deceleration.</comment>
  <expr_stmt><expr><call><name PREFIX:line="392" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="392" PREFIX:column="7">(<argument><expr><name PREFIX:line="392" PREFIX:column="8">HARD_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name PREFIX:line="395" PREFIX:column="1">void</name></type> <name><name PREFIX:line="395" PREFIX:column="6">L6470</name>::<name PREFIX:line="395" PREFIX:column="13">softFree</name></name><parameter_list PREFIX:line="395" PREFIX:column="21">()</parameter_list><block PREFIX:line="395" PREFIX:column="23">{
  <comment type="line" PREFIX:line="396" PREFIX:column="3">// Decelerate the motor and disengage</comment>
  <expr_stmt><expr><call><name PREFIX:line="397" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="397" PREFIX:column="7">(<argument><expr><name PREFIX:line="397" PREFIX:column="8">SOFT_HIZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name PREFIX:line="400" PREFIX:column="1">void</name></type> <name><name PREFIX:line="400" PREFIX:column="6">L6470</name>::<name PREFIX:line="400" PREFIX:column="13">free</name></name><parameter_list PREFIX:line="400" PREFIX:column="17">()</parameter_list><block PREFIX:line="400" PREFIX:column="19">{
  <comment type="line" PREFIX:line="401" PREFIX:column="3">// disengage the motor immediately with no deceleration.</comment>
  <expr_stmt><expr><call><name PREFIX:line="402" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="402" PREFIX:column="7">(<argument><expr><name PREFIX:line="402" PREFIX:column="8">HARD_HIZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name PREFIX:line="405" PREFIX:column="1">int</name></type> <name><name PREFIX:line="405" PREFIX:column="5">L6470</name>::<name PREFIX:line="405" PREFIX:column="12">getStatus</name></name><parameter_list PREFIX:line="405" PREFIX:column="21">()</parameter_list><block PREFIX:line="405" PREFIX:column="23">{
  <comment type="line" PREFIX:line="406" PREFIX:column="3">// Fetch and return the 16-bit value in the STATUS register. Resets</comment>
  <comment type="line" PREFIX:line="407" PREFIX:column="3">// any warning flags and exits any error states. Using GetParam()</comment>
  <comment type="line" PREFIX:line="408" PREFIX:column="3">// to read STATUS does not clear these values.</comment>
  <decl_stmt><decl><type><name PREFIX:line="409" PREFIX:column="3">int</name></type> <name PREFIX:line="409" PREFIX:column="7">temp</name> <init PREFIX:line="409" PREFIX:column="12">= <expr PREFIX:line="409" PREFIX:column="14">0</expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name PREFIX:line="410" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="410" PREFIX:column="7">(<argument><expr><name PREFIX:line="410" PREFIX:column="8">GET_STATUS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name PREFIX:line="411" PREFIX:column="3">temp</name> = <call><name PREFIX:line="411" PREFIX:column="10">Xfer</name><argument_list PREFIX:line="411" PREFIX:column="14">(<argument><expr PREFIX:line="411" PREFIX:column="15">0</expr></argument>)</argument_list></call>&lt;&lt;8</expr>;</expr_stmt>
  <expr_stmt><expr><name PREFIX:line="412" PREFIX:column="3">temp</name> |= <call><name PREFIX:line="412" PREFIX:column="11">Xfer</name><argument_list PREFIX:line="412" PREFIX:column="15">(<argument><expr PREFIX:line="412" PREFIX:column="16">0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return PREFIX:line="413" PREFIX:column="3">return <expr><name PREFIX:line="413" PREFIX:column="10">temp</name></expr>;</return>
}</block></function>

<function><type><name PREFIX:line="416" PREFIX:column="1">unknowntype</name> <name PREFIX:line="416" PREFIX:column="13">long</name></type> <name><name PREFIX:line="416" PREFIX:column="18">L6470</name>::<name PREFIX:line="416" PREFIX:column="25">AccCalc</name></name><parameter_list PREFIX:line="416" PREFIX:column="32">(<param><decl><type><name PREFIX:line="416" PREFIX:column="33">float</name></type> <name PREFIX:line="416" PREFIX:column="39">stepsPerSecPerSec</name></decl></param>)</parameter_list><block PREFIX:line="416" PREFIX:column="57">{
  <comment type="line" PREFIX:line="417" PREFIX:column="3">// The value in the ACC register is [(steps/s/s)*(tick^2)]/(2^-40) where tick is</comment>
  <comment type="line" PREFIX:line="418" PREFIX:column="3">// 250ns (datasheet value)- 0x08A on boot.</comment>
  <comment type="line" PREFIX:line="419" PREFIX:column="3">// Multiply desired steps/s/s by .137438 to get an appropriate value for this register.</comment>
  <comment type="line" PREFIX:line="420" PREFIX:column="3">// This is a 12-bit value, so we need to make sure the value is at or below 0xFFF.</comment>
  <decl_stmt><decl><type><name PREFIX:line="421" PREFIX:column="3">float</name></type> <name PREFIX:line="421" PREFIX:column="9">temp</name> <init PREFIX:line="421" PREFIX:column="14">= <expr><name PREFIX:line="421" PREFIX:column="16">stepsPerSecPerSec</name> * 0.137438</expr></init></decl>;</decl_stmt>
  <if PREFIX:line="422" PREFIX:column="3">if<condition PREFIX:line="422" PREFIX:column="5">( <expr PREFIX:line="422" PREFIX:column="7">(<name PREFIX:line="422" PREFIX:column="8">unknowntype</name> <name PREFIX:line="422" PREFIX:column="20">long</name>) <call><name PREFIX:line="422" PREFIX:column="26">long</name><argument_list PREFIX:line="422" PREFIX:column="30">(<argument><expr><name PREFIX:line="422" PREFIX:column="31">temp</name></expr></argument>)</argument_list></call> &gt; 0x00000FFF</expr>)</condition><then PREFIX:line="422" PREFIX:column="50"> <return PREFIX:line="422" PREFIX:column="51">return <expr PREFIX:line="422" PREFIX:column="58">0x00000FFF</expr>;</return></then>
  <else PREFIX:line="423" PREFIX:column="3">else <return PREFIX:line="423" PREFIX:column="8">return <expr PREFIX:line="423" PREFIX:column="15">(<name PREFIX:line="423" PREFIX:column="16">unknowntype</name> <name PREFIX:line="423" PREFIX:column="28">long</name>) <call><name PREFIX:line="423" PREFIX:column="34">long</name><argument_list PREFIX:line="423" PREFIX:column="38">(<argument><expr><name PREFIX:line="423" PREFIX:column="39">temp</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>


<function><type><name PREFIX:line="427" PREFIX:column="1">unknowntype</name> <name PREFIX:line="427" PREFIX:column="13">long</name></type> <name><name PREFIX:line="427" PREFIX:column="18">L6470</name>::<name PREFIX:line="427" PREFIX:column="25">DecCalc</name></name><parameter_list PREFIX:line="427" PREFIX:column="32">(<param><decl><type><name PREFIX:line="427" PREFIX:column="33">float</name></type> <name PREFIX:line="427" PREFIX:column="39">stepsPerSecPerSec</name></decl></param>)</parameter_list><block PREFIX:line="427" PREFIX:column="57">{
  <comment type="line" PREFIX:line="428" PREFIX:column="3">// The calculation for DEC is the same as for ACC. Value is 0x08A on boot.</comment>
  <comment type="line" PREFIX:line="429" PREFIX:column="3">// This is a 12-bit value, so we need to make sure the value is at or below 0xFFF.</comment>
  <decl_stmt><decl><type><name PREFIX:line="430" PREFIX:column="3">float</name></type> <name PREFIX:line="430" PREFIX:column="9">temp</name> <init PREFIX:line="430" PREFIX:column="14">= <expr><name PREFIX:line="430" PREFIX:column="16">stepsPerSecPerSec</name> * 0.137438</expr></init></decl>;</decl_stmt>
  <if PREFIX:line="431" PREFIX:column="3">if<condition PREFIX:line="431" PREFIX:column="5">( <expr PREFIX:line="431" PREFIX:column="7">(<name PREFIX:line="431" PREFIX:column="8">unknowntype</name> <name PREFIX:line="431" PREFIX:column="20">long</name>) <call><name PREFIX:line="431" PREFIX:column="26">long</name><argument_list PREFIX:line="431" PREFIX:column="30">(<argument><expr><name PREFIX:line="431" PREFIX:column="31">temp</name></expr></argument>)</argument_list></call> &gt; 0x00000FFF</expr>)</condition><then PREFIX:line="431" PREFIX:column="50"> <return PREFIX:line="431" PREFIX:column="51">return <expr PREFIX:line="431" PREFIX:column="58">0x00000FFF</expr>;</return></then>
  <else PREFIX:line="432" PREFIX:column="3">else <return PREFIX:line="432" PREFIX:column="8">return <expr PREFIX:line="432" PREFIX:column="15">(<name PREFIX:line="432" PREFIX:column="16">unknowntype</name> <name PREFIX:line="432" PREFIX:column="28">long</name>) <call><name PREFIX:line="432" PREFIX:column="34">long</name><argument_list PREFIX:line="432" PREFIX:column="38">(<argument><expr><name PREFIX:line="432" PREFIX:column="39">temp</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<function><type><name PREFIX:line="435" PREFIX:column="1">unknowntype</name> <name PREFIX:line="435" PREFIX:column="13">long</name></type> <name><name PREFIX:line="435" PREFIX:column="18">L6470</name>::<name PREFIX:line="435" PREFIX:column="25">MaxSpdCalc</name></name><parameter_list PREFIX:line="435" PREFIX:column="35">(<param><decl><type><name PREFIX:line="435" PREFIX:column="36">float</name></type> <name PREFIX:line="435" PREFIX:column="42">stepsPerSec</name></decl></param>)</parameter_list><block PREFIX:line="435" PREFIX:column="54">{
  <comment type="line" PREFIX:line="436" PREFIX:column="3">// The value in the MAX_SPD register is [(steps/s)*(tick)]/(2^-18) where tick is</comment>
  <comment type="line" PREFIX:line="437" PREFIX:column="3">// 250ns (datasheet value)- 0x041 on boot.</comment>
  <comment type="line" PREFIX:line="438" PREFIX:column="3">// Multiply desired steps/s by .065536 to get an appropriate value for this register</comment>
  <comment type="line" PREFIX:line="439" PREFIX:column="3">// This is a 10-bit value, so we need to make sure it remains at or below 0x3FF</comment>
  <decl_stmt><decl><type><name PREFIX:line="440" PREFIX:column="3">float</name></type> <name PREFIX:line="440" PREFIX:column="9">temp</name> <init PREFIX:line="440" PREFIX:column="14">= <expr><name PREFIX:line="440" PREFIX:column="16">stepsPerSec</name> * .065536</expr></init></decl>;</decl_stmt>
  <if PREFIX:line="441" PREFIX:column="3">if<condition PREFIX:line="441" PREFIX:column="5">( <expr PREFIX:line="441" PREFIX:column="7">(<name PREFIX:line="441" PREFIX:column="8">unknowntype</name> <name PREFIX:line="441" PREFIX:column="20">long</name>) <call><name PREFIX:line="441" PREFIX:column="26">long</name><argument_list PREFIX:line="441" PREFIX:column="30">(<argument><expr><name PREFIX:line="441" PREFIX:column="31">temp</name></expr></argument>)</argument_list></call> &gt; 0x000003FF</expr>)</condition><then PREFIX:line="441" PREFIX:column="50"> <return PREFIX:line="441" PREFIX:column="51">return <expr PREFIX:line="441" PREFIX:column="58">0x000003FF</expr>;</return></then>
  <else PREFIX:line="442" PREFIX:column="3">else <return PREFIX:line="442" PREFIX:column="8">return <expr PREFIX:line="442" PREFIX:column="15">(<name PREFIX:line="442" PREFIX:column="16">unknowntype</name> <name PREFIX:line="442" PREFIX:column="28">long</name>) <call><name PREFIX:line="442" PREFIX:column="34">long</name><argument_list PREFIX:line="442" PREFIX:column="38">(<argument><expr><name PREFIX:line="442" PREFIX:column="39">temp</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<function><type><name PREFIX:line="445" PREFIX:column="1">unknowntype</name> <name PREFIX:line="445" PREFIX:column="13">long</name></type> <name><name PREFIX:line="445" PREFIX:column="18">L6470</name>::<name PREFIX:line="445" PREFIX:column="25">MinSpdCalc</name></name><parameter_list PREFIX:line="445" PREFIX:column="35">(<param><decl><type><name PREFIX:line="445" PREFIX:column="36">float</name></type> <name PREFIX:line="445" PREFIX:column="42">stepsPerSec</name></decl></param>)</parameter_list><block PREFIX:line="445" PREFIX:column="54">{
  <comment type="line" PREFIX:line="446" PREFIX:column="3">// The value in the MIN_SPD register is [(steps/s)*(tick)]/(2^-24) where tick is</comment>
  <comment type="line" PREFIX:line="447" PREFIX:column="3">// 250ns (datasheet value)- 0x000 on boot.</comment>
  <comment type="line" PREFIX:line="448" PREFIX:column="3">// Multiply desired steps/s by 4.1943 to get an appropriate value for this register</comment>
  <comment type="line" PREFIX:line="449" PREFIX:column="3">// This is a 12-bit value, so we need to make sure the value is at or below 0xFFF.</comment>
  <decl_stmt><decl><type><name PREFIX:line="450" PREFIX:column="3">float</name></type> <name PREFIX:line="450" PREFIX:column="9">temp</name> <init PREFIX:line="450" PREFIX:column="14">= <expr><name PREFIX:line="450" PREFIX:column="16">stepsPerSec</name> * 4.1943</expr></init></decl>;</decl_stmt>
  <if PREFIX:line="451" PREFIX:column="3">if<condition PREFIX:line="451" PREFIX:column="5">( <expr PREFIX:line="451" PREFIX:column="7">(<name PREFIX:line="451" PREFIX:column="8">unknowntype</name> <name PREFIX:line="451" PREFIX:column="20">long</name>) <call><name PREFIX:line="451" PREFIX:column="26">long</name><argument_list PREFIX:line="451" PREFIX:column="30">(<argument><expr><name PREFIX:line="451" PREFIX:column="31">temp</name></expr></argument>)</argument_list></call> &gt; 0x00000FFF</expr>)</condition><then PREFIX:line="451" PREFIX:column="50"> <return PREFIX:line="451" PREFIX:column="51">return <expr PREFIX:line="451" PREFIX:column="58">0x00000FFF</expr>;</return></then>
  <else PREFIX:line="452" PREFIX:column="3">else <return PREFIX:line="452" PREFIX:column="8">return <expr PREFIX:line="452" PREFIX:column="15">(<name PREFIX:line="452" PREFIX:column="16">unknowntype</name> <name PREFIX:line="452" PREFIX:column="28">long</name>) <call><name PREFIX:line="452" PREFIX:column="34">long</name><argument_list PREFIX:line="452" PREFIX:column="38">(<argument><expr><name PREFIX:line="452" PREFIX:column="39">temp</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<function><type><name PREFIX:line="455" PREFIX:column="1">unknowntype</name> <name PREFIX:line="455" PREFIX:column="13">long</name></type> <name><name PREFIX:line="455" PREFIX:column="18">L6470</name>::<name PREFIX:line="455" PREFIX:column="25">FSCalc</name></name><parameter_list PREFIX:line="455" PREFIX:column="31">(<param><decl><type><name PREFIX:line="455" PREFIX:column="32">float</name></type> <name PREFIX:line="455" PREFIX:column="38">stepsPerSec</name></decl></param>)</parameter_list><block PREFIX:line="455" PREFIX:column="50">{
  <comment type="line" PREFIX:line="456" PREFIX:column="3">// The value in the FS_SPD register is ([(steps/s)*(tick)]/(2^-18))-0.5 where tick is</comment>
  <comment type="line" PREFIX:line="457" PREFIX:column="3">// 250ns (datasheet value)- 0x027 on boot.</comment>
  <comment type="line" PREFIX:line="458" PREFIX:column="3">// Multiply desired steps/s by .065536 and subtract .5 to get an appropriate value for this register</comment>
  <comment type="line" PREFIX:line="459" PREFIX:column="3">// This is a 10-bit value, so we need to make sure the value is at or below 0x3FF.</comment>
  <decl_stmt><decl><type><name PREFIX:line="460" PREFIX:column="3">float</name></type> <name PREFIX:line="460" PREFIX:column="9">temp</name> <init PREFIX:line="460" PREFIX:column="14">= <expr PREFIX:line="460" PREFIX:column="16">(<name PREFIX:line="460" PREFIX:column="17">stepsPerSec</name> * .065536)-.5</expr></init></decl>;</decl_stmt>
  <if PREFIX:line="461" PREFIX:column="3">if<condition PREFIX:line="461" PREFIX:column="5">( <expr PREFIX:line="461" PREFIX:column="7">(<name PREFIX:line="461" PREFIX:column="8">unknowntype</name> <name PREFIX:line="461" PREFIX:column="20">long</name>) <call><name PREFIX:line="461" PREFIX:column="26">long</name><argument_list PREFIX:line="461" PREFIX:column="30">(<argument><expr><name PREFIX:line="461" PREFIX:column="31">temp</name></expr></argument>)</argument_list></call> &gt; 0x000003FF</expr>)</condition><then PREFIX:line="461" PREFIX:column="50"> <return PREFIX:line="461" PREFIX:column="51">return <expr PREFIX:line="461" PREFIX:column="58">0x000003FF</expr>;</return></then>
  <else PREFIX:line="462" PREFIX:column="3">else <return PREFIX:line="462" PREFIX:column="8">return <expr PREFIX:line="462" PREFIX:column="15">(<name PREFIX:line="462" PREFIX:column="16">unknowntype</name> <name PREFIX:line="462" PREFIX:column="28">long</name>) <call><name PREFIX:line="462" PREFIX:column="34">long</name><argument_list PREFIX:line="462" PREFIX:column="38">(<argument><expr><name PREFIX:line="462" PREFIX:column="39">temp</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<function><type><name PREFIX:line="465" PREFIX:column="1">unknowntype</name> <name PREFIX:line="465" PREFIX:column="13">long</name></type> <name><name PREFIX:line="465" PREFIX:column="18">L6470</name>::<name PREFIX:line="465" PREFIX:column="25">IntSpdCalc</name></name><parameter_list PREFIX:line="465" PREFIX:column="35">(<param><decl><type><name PREFIX:line="465" PREFIX:column="36">float</name></type> <name PREFIX:line="465" PREFIX:column="42">stepsPerSec</name></decl></param>)</parameter_list><block PREFIX:line="465" PREFIX:column="54">{
  <comment type="line" PREFIX:line="466" PREFIX:column="3">// The value in the INT_SPD register is [(steps/s)*(tick)]/(2^-24) where tick is</comment>
  <comment type="line" PREFIX:line="467" PREFIX:column="3">// 250ns (datasheet value)- 0x408 on boot.</comment>
  <comment type="line" PREFIX:line="468" PREFIX:column="3">// Multiply desired steps/s by 4.1943 to get an appropriate value for this register</comment>
  <comment type="line" PREFIX:line="469" PREFIX:column="3">// This is a 14-bit value, so we need to make sure the value is at or below 0x3FFF.</comment>
  <decl_stmt><decl><type><name PREFIX:line="470" PREFIX:column="3">float</name></type> <name PREFIX:line="470" PREFIX:column="9">temp</name> <init PREFIX:line="470" PREFIX:column="14">= <expr><name PREFIX:line="470" PREFIX:column="16">stepsPerSec</name> * 4.1943</expr></init></decl>;</decl_stmt>
  <if PREFIX:line="471" PREFIX:column="3">if<condition PREFIX:line="471" PREFIX:column="5">( <expr PREFIX:line="471" PREFIX:column="7">(<name PREFIX:line="471" PREFIX:column="8">unknowntype</name> <name PREFIX:line="471" PREFIX:column="20">long</name>) <call><name PREFIX:line="471" PREFIX:column="26">long</name><argument_list PREFIX:line="471" PREFIX:column="30">(<argument><expr><name PREFIX:line="471" PREFIX:column="31">temp</name></expr></argument>)</argument_list></call> &gt; 0x00003FFF</expr>)</condition><then PREFIX:line="471" PREFIX:column="50"> <return PREFIX:line="471" PREFIX:column="51">return <expr PREFIX:line="471" PREFIX:column="58">0x00003FFF</expr>;</return></then>
  <else PREFIX:line="472" PREFIX:column="3">else <return PREFIX:line="472" PREFIX:column="8">return <expr PREFIX:line="472" PREFIX:column="15">(<name PREFIX:line="472" PREFIX:column="16">unknowntype</name> <name PREFIX:line="472" PREFIX:column="28">long</name>) <call><name PREFIX:line="472" PREFIX:column="34">long</name><argument_list PREFIX:line="472" PREFIX:column="38">(<argument><expr><name PREFIX:line="472" PREFIX:column="39">temp</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<function><type><name PREFIX:line="475" PREFIX:column="1">unknowntype</name> <name PREFIX:line="475" PREFIX:column="13">long</name></type> <name><name PREFIX:line="475" PREFIX:column="18">L6470</name>::<name PREFIX:line="475" PREFIX:column="25">SpdCalc</name></name><parameter_list PREFIX:line="475" PREFIX:column="32">(<param><decl><type><name PREFIX:line="475" PREFIX:column="33">float</name></type> <name PREFIX:line="475" PREFIX:column="39">stepsPerSec</name></decl></param>)</parameter_list><block PREFIX:line="475" PREFIX:column="51">{
  <comment type="line" PREFIX:line="476" PREFIX:column="3">// When issuing RUN command, the 20-bit speed is [(steps/s)*(tick)]/(2^-28) where tick is</comment>
  <comment type="line" PREFIX:line="477" PREFIX:column="3">// 250ns (datasheet value).</comment>
  <comment type="line" PREFIX:line="478" PREFIX:column="3">// Multiply desired steps/s by 67.106 to get an appropriate value for this register</comment>
  <comment type="line" PREFIX:line="479" PREFIX:column="3">// This is a 20-bit value, so we need to make sure the value is at or below 0xFFFFF.</comment>
  
  <decl_stmt><decl><type><name PREFIX:line="481" PREFIX:column="3">float</name></type> <name PREFIX:line="481" PREFIX:column="9">temp</name> <init PREFIX:line="481" PREFIX:column="14">= <expr><name PREFIX:line="481" PREFIX:column="16">stepsPerSec</name> * 67.106</expr></init></decl>;</decl_stmt>
  <if PREFIX:line="482" PREFIX:column="3">if<condition PREFIX:line="482" PREFIX:column="5">( <expr PREFIX:line="482" PREFIX:column="7">(<name PREFIX:line="482" PREFIX:column="8">unknowntype</name> <name PREFIX:line="482" PREFIX:column="20">long</name>) <call><name PREFIX:line="482" PREFIX:column="26">long</name><argument_list PREFIX:line="482" PREFIX:column="30">(<argument><expr><name PREFIX:line="482" PREFIX:column="31">temp</name></expr></argument>)</argument_list></call> &gt; 0x000FFFFF</expr>)</condition><then PREFIX:line="482" PREFIX:column="50"> <return PREFIX:line="482" PREFIX:column="51">return <expr PREFIX:line="482" PREFIX:column="58">0x000FFFFF</expr>;</return></then>
  <else PREFIX:line="483" PREFIX:column="3">else <return PREFIX:line="483" PREFIX:column="8">return <expr PREFIX:line="483" PREFIX:column="15">(<name PREFIX:line="483" PREFIX:column="16">unknowntype</name> <name PREFIX:line="483" PREFIX:column="28">long</name>)<name PREFIX:line="483" PREFIX:column="33">temp</name></expr>;</return></else></if>
}</block></function>

<function><type><name PREFIX:line="486" PREFIX:column="1">unknowntype</name> <name PREFIX:line="486" PREFIX:column="13">long</name></type> <name><name PREFIX:line="486" PREFIX:column="18">L6470</name>::<name PREFIX:line="486" PREFIX:column="25">Param</name></name><parameter_list PREFIX:line="486" PREFIX:column="30">(<param><decl><type><name PREFIX:line="486" PREFIX:column="31">unknowntype</name> <name PREFIX:line="486" PREFIX:column="43">long</name></type> <name PREFIX:line="486" PREFIX:column="48">value</name></decl></param>, <param><decl><type><name PREFIX:line="486" PREFIX:column="55">byte</name></type> <name PREFIX:line="486" PREFIX:column="60">bit_len</name></decl></param>)</parameter_list><block PREFIX:line="486" PREFIX:column="68">{
  <comment type="line" PREFIX:line="487" PREFIX:column="3">// Generalization of the subsections of the register read/write functionality.</comment>
  <comment type="line" PREFIX:line="488" PREFIX:column="3">// We want the end user to just write the value without worrying about length,</comment>
  <comment type="line" PREFIX:line="489" PREFIX:column="3">// so we pass a bit length parameter from the calling function.</comment>
  <decl_stmt><decl><type><name PREFIX:line="490" PREFIX:column="3">unknowntype</name> <name PREFIX:line="490" PREFIX:column="15">long</name></type> <name PREFIX:line="490" PREFIX:column="20">ret_val</name><init PREFIX:line="490" PREFIX:column="27">=<expr PREFIX:line="490" PREFIX:column="28">0</expr></init></decl>;</decl_stmt> <comment type="line" PREFIX:line="490" PREFIX:column="31">// We'll return this to generalize this function</comment>
  <comment type="line" PREFIX:line="491" PREFIX:column="3">// for both read and write of registers.</comment>
  <decl_stmt><decl><type><name PREFIX:line="492" PREFIX:column="3">byte</name></type> <name PREFIX:line="492" PREFIX:column="8">byte_len</name> <init PREFIX:line="492" PREFIX:column="17">= <expr><name PREFIX:line="492" PREFIX:column="19">bit_len</name>/8</expr></init></decl>;</decl_stmt> <comment type="line" PREFIX:line="492" PREFIX:column="30">// How many BYTES do we have?</comment>
  <if PREFIX:line="493" PREFIX:column="3">if <condition PREFIX:line="493" PREFIX:column="6">(<expr><name PREFIX:line="493" PREFIX:column="7">bit_len</name>%8 &gt; 0</expr>)</condition><then PREFIX:line="493" PREFIX:column="21"> <expr_stmt><expr><name PREFIX:line="493" PREFIX:column="22">byte_len</name>++</expr>;</expr_stmt></then></if> <comment type="line" PREFIX:line="493" PREFIX:column="34">// Make sure not to lose any partial byte values.</comment>
  <comment type="line" PREFIX:line="494" PREFIX:column="3">// Let's make sure our value has no spurious bits set, and if the value was too</comment>
  <comment type="line" PREFIX:line="495" PREFIX:column="3">// high, max it out.</comment>
  <decl_stmt><decl><type><name PREFIX:line="496" PREFIX:column="3">unknowntype</name> <name PREFIX:line="496" PREFIX:column="15">long</name></type> <name PREFIX:line="496" PREFIX:column="20">mask</name> <init PREFIX:line="496" PREFIX:column="25">= <expr PREFIX:line="496" PREFIX:column="27">0xffffffff &gt;&gt; (32-<name PREFIX:line="496" PREFIX:column="45">bit_len</name>)</expr></init></decl>;</decl_stmt>
  <if PREFIX:line="497" PREFIX:column="3">if <condition PREFIX:line="497" PREFIX:column="6">(<expr><name PREFIX:line="497" PREFIX:column="7">value</name> &gt; <name PREFIX:line="497" PREFIX:column="15">mask</name></expr>)</condition><then PREFIX:line="497" PREFIX:column="20"> <expr_stmt><expr><name PREFIX:line="497" PREFIX:column="21">value</name> = <name PREFIX:line="497" PREFIX:column="29">mask</name></expr>;</expr_stmt></then></if>
  <comment type="line" PREFIX:line="498" PREFIX:column="3">// The following three if statements handle the various possible byte length</comment>
  <comment type="line" PREFIX:line="499" PREFIX:column="3">// transfers- it'll be no less than 1 but no more than 3 bytes of data.</comment>
  <comment type="line" PREFIX:line="500" PREFIX:column="3">// L6470::Xfer() sends a byte out through SPI and returns a byte received</comment>
  <comment type="line" PREFIX:line="501" PREFIX:column="3">// over SPI- when calling it, we typecast a shifted version of the masked</comment>
  <comment type="line" PREFIX:line="502" PREFIX:column="3">// value, then we shift the received value back by the same amount and</comment>
  <comment type="line" PREFIX:line="503" PREFIX:column="3">// store it until return time.</comment>
  <if PREFIX:line="504" PREFIX:column="3">if <condition PREFIX:line="504" PREFIX:column="6">(<expr><name PREFIX:line="504" PREFIX:column="7">byte_len</name> == 3</expr>)</condition><then PREFIX:line="504" PREFIX:column="21"> <block PREFIX:line="504" PREFIX:column="22">{
    <expr_stmt><expr><name PREFIX:line="505" PREFIX:column="5">ret_val</name> |= <call><name PREFIX:line="505" PREFIX:column="16">long</name><argument_list PREFIX:line="505" PREFIX:column="20">(<argument><expr><call><name PREFIX:line="505" PREFIX:column="21">Xfer</name><argument_list PREFIX:line="505" PREFIX:column="25">(<argument><expr><call PREFIX:line="505" PREFIX:column="26">(<name PREFIX:line="505" PREFIX:column="27">byte</name>)<argument_list PREFIX:line="505" PREFIX:column="32">(<argument><expr><name PREFIX:line="505" PREFIX:column="33">value</name>&gt;&gt;16</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt;&lt; 16</expr>;</expr_stmt>
    <comment type="line" PREFIX:line="506" PREFIX:column="5">//Serial.println(ret_val, HEX);</comment>
  }</block></then></if>
  <if PREFIX:line="508" PREFIX:column="3">if <condition PREFIX:line="508" PREFIX:column="6">(<expr><name PREFIX:line="508" PREFIX:column="7">byte_len</name> &gt;= 2</expr>)</condition><then PREFIX:line="508" PREFIX:column="21"> <block PREFIX:line="508" PREFIX:column="22">{
    <expr_stmt><expr><name PREFIX:line="509" PREFIX:column="5">ret_val</name> |= <call><name PREFIX:line="509" PREFIX:column="16">long</name><argument_list PREFIX:line="509" PREFIX:column="20">(<argument><expr><call><name PREFIX:line="509" PREFIX:column="21">Xfer</name><argument_list PREFIX:line="509" PREFIX:column="25">(<argument><expr><call PREFIX:line="509" PREFIX:column="26">(<name PREFIX:line="509" PREFIX:column="27">byte</name>)<argument_list PREFIX:line="509" PREFIX:column="32">(<argument><expr><name PREFIX:line="509" PREFIX:column="33">value</name>&gt;&gt;8</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt;&lt; 8</expr>;</expr_stmt>
    <comment type="line" PREFIX:line="510" PREFIX:column="5">//Serial.println(ret_val, HEX);</comment>
  }</block></then></if>
  <if PREFIX:line="512" PREFIX:column="3">if <condition PREFIX:line="512" PREFIX:column="6">(<expr><name PREFIX:line="512" PREFIX:column="7">byte_len</name> &gt;= 1</expr>)</condition><then PREFIX:line="512" PREFIX:column="21"> <block PREFIX:line="512" PREFIX:column="22">{
    <expr_stmt><expr><name PREFIX:line="513" PREFIX:column="5">ret_val</name> |= <call><name PREFIX:line="513" PREFIX:column="16">Xfer</name><argument_list PREFIX:line="513" PREFIX:column="20">(<argument><expr PREFIX:line="513" PREFIX:column="21">(<name PREFIX:line="513" PREFIX:column="22">byte</name>)<name PREFIX:line="513" PREFIX:column="27">value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line" PREFIX:line="514" PREFIX:column="5">//Serial.println(ret_val, HEX);</comment>
  }</block></then></if>
  <comment type="line" PREFIX:line="516" PREFIX:column="3">// Return the received values. Mask off any unnecessary bits, just for</comment>
  <comment type="line" PREFIX:line="517" PREFIX:column="3">// the sake of thoroughness- we don't EXPECT to see anything outside</comment>
  <comment type="line" PREFIX:line="518" PREFIX:column="3">// the bit length range but better to be safe than sorry.</comment>
  <return PREFIX:line="519" PREFIX:column="3">return <expr PREFIX:line="519" PREFIX:column="10">(<name PREFIX:line="519" PREFIX:column="11">ret_val</name> &amp; <name PREFIX:line="519" PREFIX:column="21">mask</name>)</expr>;</return>
}</block></function>

<function><type><name PREFIX:line="522" PREFIX:column="1">byte</name></type> <name><name PREFIX:line="522" PREFIX:column="6">L6470</name>::<name PREFIX:line="522" PREFIX:column="13">Xfer</name></name><parameter_list PREFIX:line="522" PREFIX:column="17">(<param><decl><type><name PREFIX:line="522" PREFIX:column="18">byte</name></type> <name PREFIX:line="522" PREFIX:column="23">data</name></decl></param>)</parameter_list><block PREFIX:line="522" PREFIX:column="28">{
  <comment type="line" PREFIX:line="523" PREFIX:column="3">// This simple function shifts a byte out over SPI and receives a byte over</comment>
  <comment type="line" PREFIX:line="524" PREFIX:column="3">// SPI. Unusually for SPI devices, the dSPIN requires a toggling of the</comment>
  <comment type="line" PREFIX:line="525" PREFIX:column="3">// CS (slaveSelect) pin after each byte sent. That makes this function</comment>
  <comment type="line" PREFIX:line="526" PREFIX:column="3">// a bit more reasonable, because we can include more functionality in it.</comment>
  <decl_stmt><decl><type><name PREFIX:line="527" PREFIX:column="3">byte</name></type> <name PREFIX:line="527" PREFIX:column="8">data_out</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name PREFIX:line="528" PREFIX:column="3">digitalWrite</name><argument_list PREFIX:line="528" PREFIX:column="15">(<argument><expr><name PREFIX:line="528" PREFIX:column="16">_SSPin</name></expr></argument>,<argument><expr><name PREFIX:line="528" PREFIX:column="23">LOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line" PREFIX:line="529" PREFIX:column="3">// SPI.transfer() both shifts a byte out on the MOSI pin AND receives a</comment>
  <comment type="line" PREFIX:line="530" PREFIX:column="3">// byte in on the MISO pin.</comment>
  <expr_stmt><expr><name PREFIX:line="531" PREFIX:column="3">data_out</name> = <call><name><name PREFIX:line="531" PREFIX:column="14">SPI</name>.<name PREFIX:line="531" PREFIX:column="18">transfer</name></name><argument_list PREFIX:line="531" PREFIX:column="26">(<argument><expr><name PREFIX:line="531" PREFIX:column="27">data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name PREFIX:line="532" PREFIX:column="3">digitalWrite</name><argument_list PREFIX:line="532" PREFIX:column="15">(<argument><expr><name PREFIX:line="532" PREFIX:column="16">_SSPin</name></expr></argument>,<argument><expr><name PREFIX:line="532" PREFIX:column="23">HIGH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return PREFIX:line="533" PREFIX:column="3">return <expr><name PREFIX:line="533" PREFIX:column="10">data_out</name></expr>;</return>
}</block></function>



<function><type><name PREFIX:line="538" PREFIX:column="1">void</name></type> <name><name PREFIX:line="538" PREFIX:column="6">L6470</name>::<name PREFIX:line="538" PREFIX:column="13">SetParam</name></name><parameter_list PREFIX:line="538" PREFIX:column="21">(<param><decl><type><name PREFIX:line="538" PREFIX:column="22">byte</name></type> <name PREFIX:line="538" PREFIX:column="27">param</name></decl></param>, <param><decl><type><name PREFIX:line="538" PREFIX:column="34">unknowntype</name> <name PREFIX:line="538" PREFIX:column="46">long</name></type> <name PREFIX:line="538" PREFIX:column="51">value</name></decl></param>)</parameter_list><block PREFIX:line="538" PREFIX:column="57">{
  <expr_stmt><expr><call><name PREFIX:line="539" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="539" PREFIX:column="7">(<argument><expr><name PREFIX:line="539" PREFIX:column="8">SET_PARAM</name> | <name PREFIX:line="539" PREFIX:column="20">param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name PREFIX:line="540" PREFIX:column="3">ParamHandler</name><argument_list PREFIX:line="540" PREFIX:column="15">(<argument><expr><name PREFIX:line="540" PREFIX:column="16">param</name></expr></argument>, <argument><expr><name PREFIX:line="540" PREFIX:column="23">value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name PREFIX:line="543" PREFIX:column="1">unknowntype</name> <name PREFIX:line="543" PREFIX:column="13">long</name></type> <name><name PREFIX:line="543" PREFIX:column="18">L6470</name>::<name PREFIX:line="543" PREFIX:column="25">GetParam</name></name><parameter_list PREFIX:line="543" PREFIX:column="33">(<param><decl><type><name PREFIX:line="543" PREFIX:column="34">byte</name></type> <name PREFIX:line="543" PREFIX:column="39">param</name></decl></param>)</parameter_list><block PREFIX:line="543" PREFIX:column="45">{
  <comment type="line" PREFIX:line="544" PREFIX:column="3">// Realize the "get parameter" function, to read from the various registers in</comment>
  <comment type="line" PREFIX:line="545" PREFIX:column="3">// the dSPIN chip.</comment>
  <expr_stmt><expr><call><name PREFIX:line="546" PREFIX:column="3">Xfer</name><argument_list PREFIX:line="546" PREFIX:column="7">(<argument><expr><name PREFIX:line="546" PREFIX:column="8">GET_PARAM</name> | <name PREFIX:line="546" PREFIX:column="20">param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return PREFIX:line="547" PREFIX:column="3">return <expr><call><name PREFIX:line="547" PREFIX:column="10">ParamHandler</name><argument_list PREFIX:line="547" PREFIX:column="22">(<argument><expr><name PREFIX:line="547" PREFIX:column="23">param</name></expr></argument>, <argument><expr PREFIX:line="547" PREFIX:column="30">0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name PREFIX:line="550" PREFIX:column="1">long</name></type> <name><name PREFIX:line="550" PREFIX:column="6">L6470</name>::<name PREFIX:line="550" PREFIX:column="13">convert</name></name><parameter_list PREFIX:line="550" PREFIX:column="20">(<param><decl><type><name PREFIX:line="550" PREFIX:column="21">unknowntype</name> <name PREFIX:line="550" PREFIX:column="33">long</name></type> <name PREFIX:line="550" PREFIX:column="38">val</name></decl></param>)</parameter_list><block PREFIX:line="550" PREFIX:column="42">{
  <comment type="line" PREFIX:line="551" PREFIX:column="3">//convert 22bit 2s comp to signed long</comment>
  <decl_stmt><decl><type><name PREFIX:line="552" PREFIX:column="3">int</name></type> <name PREFIX:line="552" PREFIX:column="7">MSB</name> <init PREFIX:line="552" PREFIX:column="11">= <expr><name PREFIX:line="552" PREFIX:column="13">val</name> &gt;&gt; 21</expr></init></decl>;</decl_stmt>
  
  <expr_stmt><expr><name PREFIX:line="554" PREFIX:column="3">val</name> = <name PREFIX:line="554" PREFIX:column="9">val</name> &lt;&lt; 11</expr>;</expr_stmt>
  <expr_stmt><expr><name PREFIX:line="555" PREFIX:column="3">val</name> = <name PREFIX:line="555" PREFIX:column="9">val</name> &gt;&gt; 11</expr>;</expr_stmt>
  
  <if PREFIX:line="557" PREFIX:column="3">if<condition PREFIX:line="557" PREFIX:column="5">(<expr><name PREFIX:line="557" PREFIX:column="6">MSB</name> == 1</expr>)</condition><then PREFIX:line="557" PREFIX:column="15"> <expr_stmt><expr><name PREFIX:line="557" PREFIX:column="16">val</name> = <name PREFIX:line="557" PREFIX:column="22">val</name> | 0b11111111111000000000000000000000</expr>;</expr_stmt></then></if>
  <return PREFIX:line="558" PREFIX:column="3">return <expr><name PREFIX:line="558" PREFIX:column="10">val</name></expr>;</return>
}</block></function>

<function><type><name PREFIX:line="561" PREFIX:column="1">unknowntype</name> <name PREFIX:line="561" PREFIX:column="13">long</name></type> <name><name PREFIX:line="561" PREFIX:column="18">L6470</name>::<name PREFIX:line="561" PREFIX:column="25">ParamHandler</name></name><parameter_list PREFIX:line="561" PREFIX:column="37">(<param><decl><type><name PREFIX:line="561" PREFIX:column="38">byte</name></type> <name PREFIX:line="561" PREFIX:column="43">param</name></decl></param>, <param><decl><type><name PREFIX:line="561" PREFIX:column="50">unknowntype</name> <name PREFIX:line="561" PREFIX:column="62">long</name></type> <name PREFIX:line="561" PREFIX:column="67">value</name></decl></param>)</parameter_list><block PREFIX:line="561" PREFIX:column="73">{
  <comment type="line" PREFIX:line="562" PREFIX:column="3">// Much of the functionality between "get parameter" and "set parameter" is</comment>
  <comment type="line" PREFIX:line="563" PREFIX:column="3">// very similar, so we deal with that by putting all of it in one function</comment>
  <comment type="line" PREFIX:line="564" PREFIX:column="3">// here to save memory space and simplify the program.</comment>
  <decl_stmt><decl><type><name PREFIX:line="565" PREFIX:column="3">unknowntype</name> <name PREFIX:line="565" PREFIX:column="15">long</name></type> <name PREFIX:line="565" PREFIX:column="20">ret_val</name> <init PREFIX:line="565" PREFIX:column="28">= <expr PREFIX:line="565" PREFIX:column="30">0</expr></init></decl>;</decl_stmt> <comment type="line" PREFIX:line="565" PREFIX:column="33">// This is a temp for the value to return.</comment>
  <comment type="line" PREFIX:line="566" PREFIX:column="3">// This switch structure handles the appropriate action for each register.</comment>
  <comment type="line" PREFIX:line="567" PREFIX:column="3">// This is necessary since not all registers are of the same length, either</comment>
  <comment type="line" PREFIX:line="568" PREFIX:column="3">// bit-wise or byte-wise, so we want to make sure we mask out any spurious</comment>
  <comment type="line" PREFIX:line="569" PREFIX:column="3">// bits and do the right number of transfers. That is handled by the dSPIN_Param()</comment>
  <comment type="line" PREFIX:line="570" PREFIX:column="3">// function, in most cases, but for 1-byte or smaller transfers, we call</comment>
  <comment type="line" PREFIX:line="571" PREFIX:column="3">// Xfer() directly.</comment>
  <switch PREFIX:line="572" PREFIX:column="3">switch <condition PREFIX:line="572" PREFIX:column="10">(<expr><name PREFIX:line="572" PREFIX:column="11">param</name></expr>)</condition>
  <block PREFIX:line="573" PREFIX:column="3">{
    <comment type="line" PREFIX:line="574" PREFIX:column="5">// ABS_POS is the current absolute offset from home. It is a 22 bit number expressed</comment>
    <comment type="line" PREFIX:line="575" PREFIX:column="5">// in two's complement. At power up, this value is 0. It cannot be written when</comment>
    <comment type="line" PREFIX:line="576" PREFIX:column="5">// the motor is running, but at any other time, it can be updated to change the</comment>
    <comment type="line" PREFIX:line="577" PREFIX:column="5">// interpreted position of the motor.</comment>
    <case PREFIX:line="578" PREFIX:column="5">case <expr><name PREFIX:line="578" PREFIX:column="10">ABS_POS</name></expr>:
      <expr_stmt><expr><name PREFIX:line="579" PREFIX:column="7">ret_val</name> = <call><name PREFIX:line="579" PREFIX:column="17">Param</name><argument_list PREFIX:line="579" PREFIX:column="22">(<argument><expr><name PREFIX:line="579" PREFIX:column="23">value</name></expr></argument>, <argument><expr PREFIX:line="579" PREFIX:column="30">22</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break PREFIX:line="580" PREFIX:column="7">break;</break>
    <comment type="line" PREFIX:line="581" PREFIX:column="5">// EL_POS is the current electrical position in the step generation cycle. It can</comment>
    <comment type="line" PREFIX:line="582" PREFIX:column="5">// be set when the motor is not in motion. Value is 0 on power up.</comment>
    </case><case PREFIX:line="583" PREFIX:column="5">case <expr><name PREFIX:line="583" PREFIX:column="10">EL_POS</name></expr>:
      <expr_stmt><expr><name PREFIX:line="584" PREFIX:column="7">ret_val</name> = <call><name PREFIX:line="584" PREFIX:column="17">Param</name><argument_list PREFIX:line="584" PREFIX:column="22">(<argument><expr><name PREFIX:line="584" PREFIX:column="23">value</name></expr></argument>, <argument><expr PREFIX:line="584" PREFIX:column="30">9</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break PREFIX:line="585" PREFIX:column="7">break;</break>
    <comment type="line" PREFIX:line="586" PREFIX:column="5">// MARK is a second position other than 0 that the motor can be told to go to. As</comment>
    <comment type="line" PREFIX:line="587" PREFIX:column="5">// with ABS_POS, it is 22-bit two's complement. Value is 0 on power up.</comment>
    </case><case PREFIX:line="588" PREFIX:column="5">case <expr><name PREFIX:line="588" PREFIX:column="10">MARK</name></expr>:
      <expr_stmt><expr><name PREFIX:line="589" PREFIX:column="7">ret_val</name> = <call><name PREFIX:line="589" PREFIX:column="17">Param</name><argument_list PREFIX:line="589" PREFIX:column="22">(<argument><expr><name PREFIX:line="589" PREFIX:column="23">value</name></expr></argument>, <argument><expr PREFIX:line="589" PREFIX:column="30">22</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break PREFIX:line="590" PREFIX:column="7">break;</break>
    <comment type="line" PREFIX:line="591" PREFIX:column="5">// SPEED contains information about the current speed. It is read-only. It does</comment>
    <comment type="line" PREFIX:line="592" PREFIX:column="5">// NOT provide direction information.</comment>
    </case><case PREFIX:line="593" PREFIX:column="5">case <expr><name PREFIX:line="593" PREFIX:column="10">SPEED</name></expr>:
      <expr_stmt><expr><name PREFIX:line="594" PREFIX:column="7">ret_val</name> = <call><name PREFIX:line="594" PREFIX:column="17">Param</name><argument_list PREFIX:line="594" PREFIX:column="22">(<argument><expr PREFIX:line="594" PREFIX:column="23">0</expr></argument>, <argument><expr PREFIX:line="594" PREFIX:column="26">20</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break PREFIX:line="595" PREFIX:column="7">break;</break>
    <comment type="line" PREFIX:line="596" PREFIX:column="5">// ACC and DEC set the acceleration and deceleration rates. Set ACC to 0xFFF</comment>
    <comment type="line" PREFIX:line="597" PREFIX:column="5">// to get infinite acceleration/decelaeration- there is no way to get infinite</comment>
    <comment type="line" PREFIX:line="598" PREFIX:column="5">// deceleration w/o infinite acceleration (except the HARD STOP command).</comment>
    <comment type="line" PREFIX:line="599" PREFIX:column="5">// Cannot be written while motor is running. Both default to 0x08A on power up.</comment>
    <comment type="line" PREFIX:line="600" PREFIX:column="5">// AccCalc() and DecCalc() functions exist to convert steps/s/s values into</comment>
    <comment type="line" PREFIX:line="601" PREFIX:column="5">// 12-bit values for these two registers.</comment>
    </case><case PREFIX:line="602" PREFIX:column="5">case <expr><name PREFIX:line="602" PREFIX:column="10">ACC</name></expr>:
      <expr_stmt><expr><name PREFIX:line="603" PREFIX:column="7">ret_val</name> = <call><name PREFIX:line="603" PREFIX:column="17">Param</name><argument_list PREFIX:line="603" PREFIX:column="22">(<argument><expr><name PREFIX:line="603" PREFIX:column="23">value</name></expr></argument>, <argument><expr PREFIX:line="603" PREFIX:column="30">12</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break PREFIX:line="604" PREFIX:column="7">break;</break>
    </case><case PREFIX:line="605" PREFIX:column="5">case <expr><name PREFIX:line="605" PREFIX:column="10">DEC</name></expr>:
      <expr_stmt><expr><name PREFIX:line="606" PREFIX:column="7">ret_val</name> = <call><name PREFIX:line="606" PREFIX:column="17">Param</name><argument_list PREFIX:line="606" PREFIX:column="22">(<argument><expr><name PREFIX:line="606" PREFIX:column="23">value</name></expr></argument>, <argument><expr PREFIX:line="606" PREFIX:column="30">12</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break PREFIX:line="607" PREFIX:column="7">break;</break>
    <comment type="line" PREFIX:line="608" PREFIX:column="5">// MAX_SPEED is just what it says- any command which attempts to set the speed</comment>
    <comment type="line" PREFIX:line="609" PREFIX:column="5">// of the motor above this value will simply cause the motor to turn at this</comment>
    <comment type="line" PREFIX:line="610" PREFIX:column="5">// speed. Value is 0x041 on power up.</comment>
    <comment type="line" PREFIX:line="611" PREFIX:column="5">// MaxSpdCalc() function exists to convert steps/s value into a 10-bit value</comment>
    <comment type="line" PREFIX:line="612" PREFIX:column="5">// for this register.</comment>
    </case><case PREFIX:line="613" PREFIX:column="5">case <expr><name PREFIX:line="613" PREFIX:column="10">MAX_SPEED</name></expr>:
      <expr_stmt><expr><name PREFIX:line="614" PREFIX:column="7">ret_val</name> = <call><name PREFIX:line="614" PREFIX:column="17">Param</name><argument_list PREFIX:line="614" PREFIX:column="22">(<argument><expr><name PREFIX:line="614" PREFIX:column="23">value</name></expr></argument>, <argument><expr PREFIX:line="614" PREFIX:column="30">10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break PREFIX:line="615" PREFIX:column="7">break;</break>
    <comment type="line" PREFIX:line="616" PREFIX:column="5">// MIN_SPEED controls two things- the activation of the low-speed optimization</comment>
    <comment type="line" PREFIX:line="617" PREFIX:column="5">// feature and the lowest speed the motor will be allowed to operate at. LSPD_OPT</comment>
    <comment type="line" PREFIX:line="618" PREFIX:column="5">// is the 13th bit, and when it is set, the minimum allowed speed is automatically</comment>
    <comment type="line" PREFIX:line="619" PREFIX:column="5">// set to zero. This value is 0 on startup.</comment>
    <comment type="line" PREFIX:line="620" PREFIX:column="5">// MinSpdCalc() function exists to convert steps/s value into a 12-bit value for this</comment>
    <comment type="line" PREFIX:line="621" PREFIX:column="5">// register. SetLowSpeedOpt() function exists to enable/disable the optimization feature.</comment>
    </case><case PREFIX:line="622" PREFIX:column="5">case <expr><name PREFIX:line="622" PREFIX:column="10">MIN_SPEED</name></expr>:
      <expr_stmt><expr><name PREFIX:line="623" PREFIX:column="7">ret_val</name> = <call><name PREFIX:line="623" PREFIX:column="17">Param</name><argument_list PREFIX:line="623" PREFIX:column="22">(<argument><expr><name PREFIX:line="623" PREFIX:column="23">value</name></expr></argument>, <argument><expr PREFIX:line="623" PREFIX:column="30">12</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break PREFIX:line="624" PREFIX:column="7">break;</break>
    <comment type="line" PREFIX:line="625" PREFIX:column="5">// FS_SPD register contains a threshold value above which microstepping is disabled</comment>
    <comment type="line" PREFIX:line="626" PREFIX:column="5">// and the dSPIN operates in full-step mode. Defaults to 0x027 on power up.</comment>
    <comment type="line" PREFIX:line="627" PREFIX:column="5">// FSCalc() function exists to convert steps/s value into 10-bit integer for this</comment>
    <comment type="line" PREFIX:line="628" PREFIX:column="5">// register.</comment>
    </case><case PREFIX:line="629" PREFIX:column="5">case <expr><name PREFIX:line="629" PREFIX:column="10">FS_SPD</name></expr>:
      <expr_stmt><expr><name PREFIX:line="630" PREFIX:column="7">ret_val</name> = <call><name PREFIX:line="630" PREFIX:column="17">Param</name><argument_list PREFIX:line="630" PREFIX:column="22">(<argument><expr><name PREFIX:line="630" PREFIX:column="23">value</name></expr></argument>, <argument><expr PREFIX:line="630" PREFIX:column="30">10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break PREFIX:line="631" PREFIX:column="7">break;</break>
    <comment type="line" PREFIX:line="632" PREFIX:column="5">// KVAL is the maximum voltage of the PWM outputs. These 8-bit values are ratiometric</comment>
    <comment type="line" PREFIX:line="633" PREFIX:column="5">// representations: 255 for full output voltage, 128 for half, etc. Default is 0x29.</comment>
    <comment type="line" PREFIX:line="634" PREFIX:column="5">// The implications of different KVAL settings is too complex to dig into here, but</comment>
    <comment type="line" PREFIX:line="635" PREFIX:column="5">// it will usually work to max the value for RUN, ACC, and DEC. Maxing the value for</comment>
    <comment type="line" PREFIX:line="636" PREFIX:column="5">// HOLD may result in excessive power dissipation when the motor is not running.</comment>
    </case><case PREFIX:line="637" PREFIX:column="5">case <expr><name PREFIX:line="637" PREFIX:column="10">KVAL_HOLD</name></expr>:
      <expr_stmt><expr><name PREFIX:line="638" PREFIX:column="7">ret_val</name> = <call><name PREFIX:line="638" PREFIX:column="17">Xfer</name><argument_list PREFIX:line="638" PREFIX:column="21">(<argument><expr PREFIX:line="638" PREFIX:column="22">(<name PREFIX:line="638" PREFIX:column="23">byte</name>)<name PREFIX:line="638" PREFIX:column="28">value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break PREFIX:line="639" PREFIX:column="7">break;</break>
    </case><case PREFIX:line="640" PREFIX:column="5">case <expr><name PREFIX:line="640" PREFIX:column="10">KVAL_RUN</name></expr>:
      <expr_stmt><expr><name PREFIX:line="641" PREFIX:column="7">ret_val</name> = <call><name PREFIX:line="641" PREFIX:column="17">Xfer</name><argument_list PREFIX:line="641" PREFIX:column="21">(<argument><expr PREFIX:line="641" PREFIX:column="22">(<name PREFIX:line="641" PREFIX:column="23">byte</name>)<name PREFIX:line="641" PREFIX:column="28">value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break PREFIX:line="642" PREFIX:column="7">break;</break>
    </case><case PREFIX:line="643" PREFIX:column="5">case <expr><name PREFIX:line="643" PREFIX:column="10">KVAL_ACC</name></expr>:
      <expr_stmt><expr><name PREFIX:line="644" PREFIX:column="7">ret_val</name> = <call><name PREFIX:line="644" PREFIX:column="17">Xfer</name><argument_list PREFIX:line="644" PREFIX:column="21">(<argument><expr PREFIX:line="644" PREFIX:column="22">(<name PREFIX:line="644" PREFIX:column="23">byte</name>)<name PREFIX:line="644" PREFIX:column="28">value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break PREFIX:line="645" PREFIX:column="7">break;</break>
    </case><case PREFIX:line="646" PREFIX:column="5">case <expr><name PREFIX:line="646" PREFIX:column="10">KVAL_DEC</name></expr>:
      <expr_stmt><expr><name PREFIX:line="647" PREFIX:column="7">ret_val</name> = <call><name PREFIX:line="647" PREFIX:column="17">Xfer</name><argument_list PREFIX:line="647" PREFIX:column="21">(<argument><expr PREFIX:line="647" PREFIX:column="22">(<name PREFIX:line="647" PREFIX:column="23">byte</name>)<name PREFIX:line="647" PREFIX:column="28">value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break PREFIX:line="648" PREFIX:column="7">break;</break>
    <comment type="line" PREFIX:line="649" PREFIX:column="5">// INT_SPD, ST_SLP, FN_SLP_ACC and FN_SLP_DEC are all related to the back EMF</comment>
    <comment type="line" PREFIX:line="650" PREFIX:column="5">// compensation functionality. Please see the datasheet for details of this</comment>
    <comment type="line" PREFIX:line="651" PREFIX:column="5">// function- it is too complex to discuss here. Default values seem to work</comment>
    <comment type="line" PREFIX:line="652" PREFIX:column="5">// well enough.</comment>
    </case><case PREFIX:line="653" PREFIX:column="5">case <expr><name PREFIX:line="653" PREFIX:column="10">INT_SPD</name></expr>:
      <expr_stmt><expr><name PREFIX:line="654" PREFIX:column="7">ret_val</name> = <call><name PREFIX:line="654" PREFIX:column="17">Param</name><argument_list PREFIX:line="654" PREFIX:column="22">(<argument><expr><name PREFIX:line="654" PREFIX:column="23">value</name></expr></argument>, <argument><expr PREFIX:line="654" PREFIX:column="30">14</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break PREFIX:line="655" PREFIX:column="7">break;</break>
    </case><case PREFIX:line="656" PREFIX:column="5">case <expr><name PREFIX:line="656" PREFIX:column="10">ST_SLP</name></expr>:
      <expr_stmt><expr><name PREFIX:line="657" PREFIX:column="7">ret_val</name> = <call><name PREFIX:line="657" PREFIX:column="17">Xfer</name><argument_list PREFIX:line="657" PREFIX:column="21">(<argument><expr PREFIX:line="657" PREFIX:column="22">(<name PREFIX:line="657" PREFIX:column="23">byte</name>)<name PREFIX:line="657" PREFIX:column="28">value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break PREFIX:line="658" PREFIX:column="7">break;</break>
    </case><case PREFIX:line="659" PREFIX:column="5">case <expr><name PREFIX:line="659" PREFIX:column="10">FN_SLP_ACC</name></expr>:
      <expr_stmt><expr><name PREFIX:line="660" PREFIX:column="7">ret_val</name> = <call><name PREFIX:line="660" PREFIX:column="17">Xfer</name><argument_list PREFIX:line="660" PREFIX:column="21">(<argument><expr PREFIX:line="660" PREFIX:column="22">(<name PREFIX:line="660" PREFIX:column="23">byte</name>)<name PREFIX:line="660" PREFIX:column="28">value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break PREFIX:line="661" PREFIX:column="7">break;</break>
    </case><case PREFIX:line="662" PREFIX:column="5">case <expr><name PREFIX:line="662" PREFIX:column="10">FN_SLP_DEC</name></expr>:
      <expr_stmt><expr><name PREFIX:line="663" PREFIX:column="7">ret_val</name> = <call><name PREFIX:line="663" PREFIX:column="17">Xfer</name><argument_list PREFIX:line="663" PREFIX:column="21">(<argument><expr PREFIX:line="663" PREFIX:column="22">(<name PREFIX:line="663" PREFIX:column="23">byte</name>)<name PREFIX:line="663" PREFIX:column="28">value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break PREFIX:line="664" PREFIX:column="7">break;</break>
    <comment type="line" PREFIX:line="665" PREFIX:column="5">// K_THERM is motor winding thermal drift compensation. Please see the datasheet</comment>
    <comment type="line" PREFIX:line="666" PREFIX:column="5">// for full details on operation- the default value should be okay for most users.</comment>
    </case><case PREFIX:line="667" PREFIX:column="5">case <expr><name PREFIX:line="667" PREFIX:column="10">K_THERM</name></expr>:
      <expr_stmt><expr><name PREFIX:line="668" PREFIX:column="7">ret_val</name> = <call><name PREFIX:line="668" PREFIX:column="17">Xfer</name><argument_list PREFIX:line="668" PREFIX:column="21">(<argument><expr PREFIX:line="668" PREFIX:column="22">(<name PREFIX:line="668" PREFIX:column="23">byte</name>)<name PREFIX:line="668" PREFIX:column="28">value</name> &amp; 0x0F</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break PREFIX:line="669" PREFIX:column="7">break;</break>
    <comment type="line" PREFIX:line="670" PREFIX:column="5">// ADC_OUT is a read-only register containing the result of the ADC measurements.</comment>
    <comment type="line" PREFIX:line="671" PREFIX:column="5">// This is less useful than it sounds; see the datasheet for more information.</comment>
    </case><case PREFIX:line="672" PREFIX:column="5">case <expr><name PREFIX:line="672" PREFIX:column="10">ADC_OUT</name></expr>:
      <expr_stmt><expr><name PREFIX:line="673" PREFIX:column="7">ret_val</name> = <call><name PREFIX:line="673" PREFIX:column="17">Xfer</name><argument_list PREFIX:line="673" PREFIX:column="21">(<argument><expr PREFIX:line="673" PREFIX:column="22">0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break PREFIX:line="674" PREFIX:column="7">break;</break>
    <comment type="line" PREFIX:line="675" PREFIX:column="5">// Set the overcurrent threshold. Ranges from 375mA to 6A in steps of 375mA.</comment>
    <comment type="line" PREFIX:line="676" PREFIX:column="5">// A set of defined ants is provided for the user's convenience. Default</comment>
    <comment type="line" PREFIX:line="677" PREFIX:column="5">// value is 3.375A- 0x08. This is a 4-bit value.</comment>
    </case><case PREFIX:line="678" PREFIX:column="5">case <expr><name PREFIX:line="678" PREFIX:column="10">OCD_TH</name></expr>:
      <expr_stmt><expr><name PREFIX:line="679" PREFIX:column="7">ret_val</name> = <call><name PREFIX:line="679" PREFIX:column="17">Xfer</name><argument_list PREFIX:line="679" PREFIX:column="21">(<argument><expr PREFIX:line="679" PREFIX:column="22">(<name PREFIX:line="679" PREFIX:column="23">byte</name>)<name PREFIX:line="679" PREFIX:column="28">value</name> &amp; 0x0F</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break PREFIX:line="680" PREFIX:column="7">break;</break>
    <comment type="line" PREFIX:line="681" PREFIX:column="5">// Stall current threshold. Defaults to 0x40, or 2.03A. Value is from 31.25mA to</comment>
    <comment type="line" PREFIX:line="682" PREFIX:column="5">// 4A in 31.25mA steps. This is a 7-bit value.</comment>
    </case><case PREFIX:line="683" PREFIX:column="5">case <expr><name PREFIX:line="683" PREFIX:column="10">STALL_TH</name></expr>:
      <expr_stmt><expr><name PREFIX:line="684" PREFIX:column="7">ret_val</name> = <call><name PREFIX:line="684" PREFIX:column="17">Xfer</name><argument_list PREFIX:line="684" PREFIX:column="21">(<argument><expr PREFIX:line="684" PREFIX:column="22">(<name PREFIX:line="684" PREFIX:column="23">byte</name>)<name PREFIX:line="684" PREFIX:column="28">value</name> &amp; 0x7F</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break PREFIX:line="685" PREFIX:column="7">break;</break>
    <comment type="line" PREFIX:line="686" PREFIX:column="5">// STEP_MODE controls the microstepping settings, as well as the generation of an</comment>
    <comment type="line" PREFIX:line="687" PREFIX:column="5">// output signal from the dSPIN. Bits 2:0 control the number of microsteps per</comment>
    <comment type="line" PREFIX:line="688" PREFIX:column="5">// step the part will generate. Bit 7 controls whether the BUSY/SYNC pin outputs</comment>
    <comment type="line" PREFIX:line="689" PREFIX:column="5">// a BUSY signal or a step synchronization signal. Bits 6:4 control the frequency</comment>
    <comment type="line" PREFIX:line="690" PREFIX:column="5">// of the output signal relative to the full-step frequency; see datasheet for</comment>
    <comment type="line" PREFIX:line="691" PREFIX:column="5">// that relationship as it is too complex to reproduce here.</comment>
    <comment type="line" PREFIX:line="692" PREFIX:column="5">// Most likely, only the microsteps per step value will be needed; there is a set</comment>
    <comment type="line" PREFIX:line="693" PREFIX:column="5">// of ants provided for ease of use of these values.</comment>
    </case><case PREFIX:line="694" PREFIX:column="5">case <expr><name PREFIX:line="694" PREFIX:column="10">STEP_MODE</name></expr>:
      <expr_stmt><expr><name PREFIX:line="695" PREFIX:column="7">ret_val</name> = <call><name PREFIX:line="695" PREFIX:column="17">Xfer</name><argument_list PREFIX:line="695" PREFIX:column="21">(<argument><expr PREFIX:line="695" PREFIX:column="22">(<name PREFIX:line="695" PREFIX:column="23">byte</name>)<name PREFIX:line="695" PREFIX:column="28">value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break PREFIX:line="696" PREFIX:column="7">break;</break>
    <comment type="line" PREFIX:line="697" PREFIX:column="5">// ALARM_EN controls which alarms will cause the FLAG pin to fall. A set of ants</comment>
    <comment type="line" PREFIX:line="698" PREFIX:column="5">// is provided to make this easy to interpret. By default, ALL alarms will trigger the</comment>
    <comment type="line" PREFIX:line="699" PREFIX:column="5">// FLAG pin.</comment>
    </case><case PREFIX:line="700" PREFIX:column="5">case <expr><name PREFIX:line="700" PREFIX:column="10">ALARM_EN</name></expr>:
      <expr_stmt><expr><name PREFIX:line="701" PREFIX:column="7">ret_val</name> = <call><name PREFIX:line="701" PREFIX:column="17">Xfer</name><argument_list PREFIX:line="701" PREFIX:column="21">(<argument><expr PREFIX:line="701" PREFIX:column="22">(<name PREFIX:line="701" PREFIX:column="23">byte</name>)<name PREFIX:line="701" PREFIX:column="28">value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break PREFIX:line="702" PREFIX:column="7">break;</break>
    <comment type="line" PREFIX:line="703" PREFIX:column="5">// CONFIG contains some assorted configuration bits and fields. A fairly comprehensive</comment>
    <comment type="line" PREFIX:line="704" PREFIX:column="5">// set of reasonably self-explanatory ants is provided, but users should refer</comment>
    <comment type="line" PREFIX:line="705" PREFIX:column="5">// to the datasheet before modifying the contents of this register to be certain they</comment>
    <comment type="line" PREFIX:line="706" PREFIX:column="5">// understand the implications of their modifications. Value on boot is 0x2E88; this</comment>
    <comment type="line" PREFIX:line="707" PREFIX:column="5">// can be a useful way to verify proper start up and operation of the dSPIN chip.</comment>
    </case><case PREFIX:line="708" PREFIX:column="5">case <expr><name PREFIX:line="708" PREFIX:column="10">CONFIG</name></expr>:
      <expr_stmt><expr><name PREFIX:line="709" PREFIX:column="7">ret_val</name> = <call><name PREFIX:line="709" PREFIX:column="17">Param</name><argument_list PREFIX:line="709" PREFIX:column="22">(<argument><expr><name PREFIX:line="709" PREFIX:column="23">value</name></expr></argument>, <argument><expr PREFIX:line="709" PREFIX:column="30">16</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break PREFIX:line="710" PREFIX:column="7">break;</break>
      <comment type="line" PREFIX:line="711" PREFIX:column="7">// STATUS contains read-only information about the current condition of the chip. A</comment>
      <comment type="line" PREFIX:line="712" PREFIX:column="7">// comprehensive set of ants for masking and testing this register is provided, but</comment>
      <comment type="line" PREFIX:line="713" PREFIX:column="7">// users should refer to the datasheet to ensure that they fully understand each one of</comment>
      <comment type="line" PREFIX:line="714" PREFIX:column="7">// the bits in the register.</comment>
    </case><case PREFIX:line="715" PREFIX:column="5">case <expr><name PREFIX:line="715" PREFIX:column="10">STATUS</name></expr>: <comment type="line" PREFIX:line="715" PREFIX:column="18">// STATUS is a read-only register</comment>
      <expr_stmt><expr><name PREFIX:line="716" PREFIX:column="7">ret_val</name> = <call><name PREFIX:line="716" PREFIX:column="17">Param</name><argument_list PREFIX:line="716" PREFIX:column="22">(<argument><expr PREFIX:line="716" PREFIX:column="23">0</expr></argument>, <argument><expr PREFIX:line="716" PREFIX:column="26">16</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break PREFIX:line="717" PREFIX:column="7">break;</break>
    </case><default PREFIX:line="718" PREFIX:column="5">default:
      <expr_stmt><expr><name PREFIX:line="719" PREFIX:column="7">ret_val</name> = <call><name PREFIX:line="719" PREFIX:column="17">Xfer</name><argument_list PREFIX:line="719" PREFIX:column="21">(<argument><expr><call PREFIX:line="719" PREFIX:column="22">(<name PREFIX:line="719" PREFIX:column="23">byte</name>)<argument_list PREFIX:line="719" PREFIX:column="28">(<argument><expr><name PREFIX:line="719" PREFIX:column="29">value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break PREFIX:line="720" PREFIX:column="5">break;</break>
  </default>}</block></switch>
  <return PREFIX:line="722" PREFIX:column="3">return <expr><name PREFIX:line="722" PREFIX:column="10">ret_val</name></expr>;</return>
}</block></function>
</unit>
